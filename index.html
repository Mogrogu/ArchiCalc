<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArchiCalc Beta 1.0</title>
    <link rel="icon" href=" CalcIcon.png" onerror="this.href='https://placehold.co/16x16/f97316/ffffff?text=AC'">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23f97316'%3E%3Cpath d='M12 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h8zM4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H4z'/%3E%3Cpath d='M4 2.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-2zm0 4a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm3-6a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm3-6a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-4z'/%3E%3C/svg%3E" type="image/svg+xml">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base body styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* Tailwind gray-50 (Light mode default) */
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 0.5rem; 
            box-sizing: border-box;
            transition: background-color 0.3s ease;
        }

        /* Dark mode body styles */
        body.dark-mode {
            background-color: #111827; /* Tailwind gray-900 */
        }

        @media (min-width: 640px) { /* sm breakpoint */
            body {
                padding: 1rem;
            }
        }

        .calculator {
            width: 100%;
            max-width: 400px; 
            border: 1px solid #d1d5db; /* Tailwind gray-300 (Light) */
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.05), 0 1px 2px -1px rgba(0, 0, 0, 0.03);
            background-color: #ffffff; /* White background (Light) */
            border-radius: 0.5rem; 
            overflow: hidden; 
            display: flex;
            flex-direction: column;
            height: calc(100vh - 1rem); 
            max-height: 700px; 
            position: relative; 
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        /* Dark mode calculator styles */
        .calculator.dark-mode {
            background-color: #1f2937; /* Tailwind gray-800 */
            border: 1px solid #4b5563; /* Tailwind gray-600 */
        }


         @media (min-width: 640px) { /* sm breakpoint */
             .calculator {
                 height: calc(100vh - 2rem); 
             }
         }

        .app-title {
            background-color: #f97316; /* Tailwind orange-500 (Light) */
            color: #ffffff; /* White text (Light) */
            text-align: center; 
            padding: 0.01rem 1rem; 
            font-size: 1.2rem; 
            font-weight: 600; 
            letter-spacing: 0.1rem; 
            flex-shrink: 0; 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            position: relative; 
            min-height: 36px; 
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* Dark mode app title */
        .calculator.dark-mode .app-title {
            background-color: #7c2d12; /* Tailwind orange-800 */
            color: #fed7aa; /* Tailwind orange-200 */
        }
        .app-title-text {
            flex-grow: 1; 
            text-align: center; 
        }
        .info-icon {
             cursor: pointer;
             padding: 0.25rem; 
             line-height: 1; 
        }
        .info-icon svg {
            transition: fill 0.3s ease;
        }
        /* Info icon in dark mode will inherit color from .app-title */

        .top-section {
            display: flex;
            flex-direction: column;
            flex-grow: 1; 
            overflow: hidden; 
        }

        .history-tape {
            background-color: #f3f4f6; /* Tailwind gray-100 (Light) */
            border-bottom: 1px solid #d1d5db; /* Tailwind gray-300 (Light) */
            flex-grow: 1; 
            overflow-y: auto; 
            padding: 5px 15px;
            color: #6b7280; /* Tailwind gray-500 (Light) */
            font-size: 0.75rem; 
            text-align: right;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: flex-end; 
            white-space: nowrap; 
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        /* Dark mode history tape */
        .calculator.dark-mode .history-tape {
            background-color: #374151; /* Tailwind gray-700 */
            color: #d1d5db; /* Tailwind gray-300 */
            border-bottom: 1px solid #4b5563; /* Tailwind gray-600 */
        }
         .history-item {
             width: 100%;
             overflow: hidden;
             text-overflow: ellipsis; 
         }
         /* Dark mode history item strong tag */
        .calculator.dark-mode .history-item strong {
            color: #fde047; /* Tailwind yellow-400 for emphasis */
        }


        .display-container {
             background-color: #e5e7eb; /* Tailwind gray-200 (Light) */
             border-bottom: 1px solid #d1d5db; /* Tailwind gray-300 (Light) */
             min-height: 70px; 
             padding: 10px 15px;
             color: #1f2937; /* Tailwind gray-800 (Light) */
             display: flex;
             flex-direction: column;
             justify-content: center; 
             align-items: flex-end; 
             box-sizing: border-box;
             word-break: break-all; 
             flex-shrink: 0; 
             transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        /* Dark mode display container */
        .calculator.dark-mode .display-container {
            background-color: #111827; /* Tailwind gray-900 */
            color: #f9fafb; /* Tailwind gray-50 */
            border-bottom: 1px solid #374151; /* Tailwind gray-700 */
        }

        .display-main {
            font-size: 2rem; 
            font-weight: 600; 
            overflow: hidden; 
            white-space: nowrap; 
            width: 100%;
            text-align: right;
            min-height: 1.2em; 
            transition: color 0.3s ease;
        }
        /* Dark mode display main text (already covered by .display-container.dark-mode color) */
        /* .calculator.dark-mode .display-main { color: #f9fafb; } */

         .display-dimensional {
            font-size: 0.9rem; 
            color: #4b5563; /* Tailwind gray-600 (Light) */
            height: 1.2em; 
            width: 100%;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.3s ease;
        }
        /* Dark mode display dimensional text */
        .calculator.dark-mode .display-dimensional {
            color: #9ca3af; /* Tailwind gray-400 */
        }

        .buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr); 
            gap: 1px; 
            background-color: #d1d5db; /* Tailwind gray-300 for grid lines (Light) */
            flex-shrink: 0; 
            transition: background-color 0.3s ease;
        }
        /* Dark mode button grid lines */
        .calculator.dark-mode .buttons {
            background-color: #1f2937; /* Tailwind gray-800 */
        }

        .btn {
            background-color: #ffffff; /* White button background (Light) */
            border: none;
            text-align: center;
            font-size: 1rem;
            font-weight: 600; 
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease; 
            color: #1f2937; /* Tailwind gray-800 text (Light) */
            width: 100%;
            height: 60px; 
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px 5px; 
            box-sizing: border-box;
        }
        /* Dark mode default button */
        .calculator.dark-mode .btn {
            background-color: #4b5563; /* Tailwind gray-600 */
            color: #f9fafb; /* Tailwind gray-50 */
        }
        .calculator.dark-mode .btn:hover { background-color: #374151; } /* Tailwind gray-700 */
        .calculator.dark-mode .btn:active { background-color: #525a66; } /* Slightly lighter gray for active */


        .shortcut {
            font-weight: 200; 
            margin-left: 0.25rem; 
            opacity: 0.8; 
        }
        /* Dark mode shortcut text */
        .calculator.dark-mode .shortcut {
            opacity: 0.7;
            color: #cbd5e1; /* Tailwind slate-300 */
        }


        .btn:hover { background-color: #e5e7eb; } /* Tailwind gray-200 on hover (Light) */
        .btn:active { background-color: #d1d5db; } /* Tailwind gray-300 on active (Light) */

        /* Button Color Styles - Light Mode */
        .btn-op { background-color: #22d3ee; color: #083344; } 
        .btn-op:hover { background-color: #06b6d4; } 
        .btn-unit { background-color: #e0f2fe; color: #075985; } 
        .btn-unit:hover { background-color: #bae6fd; } 
        .btn-conv { background-color: #bfdbfe; color: #1e40af; } 
        .btn-conv:hover { background-color: #93c5fd; } 
        .btn-ctrl { background-color: #d1d5db; color: #374151; } 
        .btn-ctrl:hover { background-color: #9ca3af; }
        .btn-backspace-yellow { background-color: #fef9c3; color: #854d0e; }
        .btn-backspace-yellow:hover { background-color: #fde047; }
        .btn-equal { background-color: #0e7490; color: #ffffff; } 
        .btn-equal:hover { background-color: #155e75; } 
        .btn-mem { background-color: #eef2ff; color: #4338ca; } 
        .btn-mem:hover { background-color: #c7d2fe; } 
        .btn-frac { background-color: #e0f2fe; color: #075985; } 
        .btn-frac:hover { background-color: #bae6fd; } 

        /* Button Color Styles - Dark Mode */
        .calculator.dark-mode .btn-op { background-color: #0891b2; color: #ecfeff; }
        .calculator.dark-mode .btn-op:hover { background-color: #0e7490; }
        .calculator.dark-mode .btn-unit { background-color: #0c4a6e; color: #e0f2fe; }
        .calculator.dark-mode .btn-unit:hover { background-color: #075985; }
        .calculator.dark-mode .btn-conv { background-color: #1e40af; color: #dbeafe; }
        .calculator.dark-mode .btn-conv:hover { background-color: #1e3a8a; }
        .calculator.dark-mode .btn-ctrl { background-color: #1f2937; color: #d1d5db; } /* Control buttons in dark mode */
        .calculator.dark-mode .btn-ctrl:hover { background-color: #4b5563; }
        .calculator.dark-mode .btn-backspace-yellow { background-color: #713f12; color: #fefce8; } /* Amber-800, Amber-50 */
        .calculator.dark-mode .btn-backspace-yellow:hover { background-color: #854d0e; }
        .calculator.dark-mode .btn-equal { background-color: #155e75; color: #ffffff; }
        .calculator.dark-mode .btn-equal:hover { background-color: #083344; }
        .calculator.dark-mode .btn-mem { background-color: #312e81; color: #e0e7ff; }
        .calculator.dark-mode .btn-mem:hover { background-color: #3730a3; }
        .calculator.dark-mode .btn-frac { background-color: #0c4a6e; color: #e0f2fe; } /* Same as unit for dark */
        .calculator.dark-mode .btn-frac:hover { background-color: #075985; }


        /* Span button across columns */
        .col-span-1 { grid-column: span 1 / span 1; }
        .col-span-2 { grid-column: span 2 / span 2; }
        .col-span-3 { grid-column: span 3 / span 3; }
        .col-span-4 { grid-column: span 4 / span 4; }
        .col-span-5 { grid-column: span 5 / span 5; }


        .flashing { animation: flash 1s infinite alternate; }
        @keyframes flash { from { opacity: 1; } to { opacity: 0.5; } }

        /* Modal Styles */
        .modal {
            position: fixed; inset: 0;
            background-color: rgba(0, 0, 0, 0.6); 
            display: flex; align-items: center; justify-content: center;
            z-index: 50; padding: 1rem;
        }
        .modal-content {
            background-color: white; /* Light mode */
            padding: 1.5rem; border-radius: 0.5rem;
            max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative;
            color: #374151; /* Light mode text */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .calculator.dark-mode .modal-content {
            background-color: #262f3d; /* Slightly lighter than calculator body dark */
            color: #d1d5db; /* Tailwind gray-300 */
        }
         .modal-content h1, .modal-content h2 {
             color: #1f2937; /* Light mode */
             margin-top: 1rem; margin-bottom: 0.5rem; font-weight: 600;
             transition: color 0.3s ease;
         }
         .calculator.dark-mode .modal-content h1, .calculator.dark-mode .modal-content h2 {
             color: #f3f4f6; /* Tailwind gray-100 */
         }
         .modal-content h1 { font-size: 1.5rem; }
         .modal-content h2 { font-size: 1.25rem; }
         .modal-content p, .modal-content li {
             margin-bottom: 0.75rem; line-height: 1.6;
         }
         .modal-content ul { list-style: disc; margin-left: 1.5rem; }
         .modal-content code {
            background-color: #e5e7eb; /* Light mode */
            padding: 0.1rem 0.3rem; border-radius: 0.25rem; font-size: 0.85em;
            transition: background-color 0.3s ease, color 0.3s ease;
         }
         .calculator.dark-mode .modal-content code {
            background-color: #4b5563; /* Tailwind gray-600 */
            color: #e0f2fe; /* sky-100 */
         }
         .modal-close-btn {
            position: absolute; top: 0.5rem; right: 0.75rem;
            background: none; border: none;
            font-size: 1.5rem; font-weight: bold;
            color: #9ca3af; /* Light mode */
            cursor: pointer; line-height: 1;
            transition: color 0.3s ease;
         }
         .calculator.dark-mode .modal-close-btn {
             color: #6b7280; /* Tailwind gray-500 */
         }
         .modal-close-btn:hover { color: #6b7280; /* Light mode hover */ }
         .calculator.dark-mode .modal-close-btn:hover { color: #9ca3af; /* Tailwind gray-400 */ }

    </style>
</head>
<body>

    <div class="calculator" id="calculator"> <div class="app-title">
            <span class="w-8"></span> <span class="app-title-text">ArchiCalc Beta</span>
            <span id="info-button" class="info-icon" title="About ArchiCalc">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-info-circle-fill" viewBox="0 0 16 16">
                  <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
                </svg>
            </span>
        </div>

        <div class="top-section">
            <div id="historyTape" class="history-tape"></div>
            <div class="display-container">
                <div id="displayDimensional" class="display-dimensional"></div>
                <div id="displayValue" class="display-main">0</div>
            </div>
        </div>

        <div class="buttons">
            <button class="btn btn-unit" data-unit="yd" title="Convert to Yards / Square Yards / Cubic Yards">Yards</button>
            <button class="btn btn-unit" data-unit="ft" title="Convert to Feet / Square Feet / Cubic Feet">Feet<span class="shortcut">(')</span></button>
            <button class="btn btn-unit" data-unit="in" title="Convert to Inches / Square Inches / Cubic Inches">Inch<span class="shortcut">(;)</span></button>
            <button class="btn btn-frac" data-action="fraction"><sup>x</sup>&frasl;<sub>x</sub><span class="shortcut">(\)</span></button>
            <button class="btn btn-backspace-yellow" data-action="backspace">←</button>

            <button class="btn btn-unit" data-unit="cm" title="Convert to Centimeters / Square Centimeters / Cubic Centimeters">cm</button>
            <button class="btn btn-unit" data-unit="mm" title="Convert to Millimeters / Square Millimeters / Cubic Millimeters">mm</button>
            <button class="btn btn-unit" data-unit="m" title="Convert to Meters / Square Meters / Cubic Meters">m</button>
            <button class="btn btn-op" data-action="divide">÷</button>
            <button class="btn btn-conv" data-action="convert">Conv</button>

            <button class="btn" data-number="7">7</button>
            <button class="btn" data-number="8">8</button>
            <button class="btn" data-number="9">9</button>
            <button class="btn btn-op" data-action="multiply">×</button>
            <button class="btn btn-mem" data-action="memory-recall">MR</button>

            <button class="btn" data-number="4">4</button>
            <button class="btn" data-number="5">5</button>
            <button class="btn" data-number="6">6</button>
            <button class="btn btn-op" data-action="subtract">−</button>
            <button class="btn btn-mem" data-action="memory-clear">MC</button>

            <button class="btn" data-number="1">1</button>
            <button class="btn" data-number="2">2</button>
            <button class="btn" data-number="3">3</button>
            <button class="btn btn-op" data-action="add">+</button>
            <button class="btn btn-mem" data-action="memory-add">M+</button>

            <button class="btn" data-number="0">0</button>
            <button class="btn" data-action="decimal">.</button>
            <button class="btn" data-action="sign">+/-</button>
            <button class="btn btn-equal col-span-2" data-action="calculate">=</button>

            <button class="btn btn-ctrl" data-action="clear-history">Clear Tape</button>
            <button class="btn btn-ctrl" data-action="clear">On/C</button>
            <button id="darkModeToggle" class="btn btn-ctrl" title="Toggle Dark Mode">🌙</button>
            </div>

        <img src="https://raw.githubusercontent.com/Mogrogu/ArchiCalc/main/UAI%20LOGO.png"
             alt="UAI Logo"
             id="uaiLogo"
             class="absolute bottom-2.5 right-2.5 w-[80px] rounded z-10" 
             onerror="this.style.display='none'; document.getElementById('uaiLogoPlaceholder').style.display='block';"
             style="transition: filter 0.3s ease;">
        <img src="https://placehold.co/80x30/ffffff/000000?text=UAI" 
             alt="UAI Logo Placeholder" 
             id="uaiLogoPlaceholder" 
             class="absolute bottom-2.5 right-2.5 w-[80px] rounded z-10" 
             style="display:none;">
    </div>

    <div id="notice-modal" class="modal hidden">
        <div class="modal-content"> <button id="modal-close-button" class="modal-close-btn">&times;</button>
            <h1>ArchiCalc Beta</h1>
            <p>> ⚠️ <strong>Note:</strong> This is a <strong>beta release</strong> currently in the testing stage. Functionality and accuracy are still being evaluated. Feedback and bug reports are welcome.</p>
            <p><strong>ArchiCalc</strong> is a browser-based calculator designed specifically for architects, builders, and planners to perform precise dimensional calculations. It supports entry and manipulation of measurements in feet, inches, and fractions — and seamlessly converts between imperial and metric units. Perfect for planning, drafting, and on-site work where quick unit conversions and dimensional calculations are required.</p>
            <h2>Features</h2>
            <ul>
                <li><strong>Dimensional Input:</strong> Work in feet, inches, and fractional inches (e.g., <code>5 ft 6 3/8 in</code>).</li>
                <li><strong>Measurement Modes:</strong> Compute linear, area (sq. ft/in), and volume (cu. ft/in) values.</li>
                <li><strong>Metric Conversion:</strong> Convert between imperial and metric (meters, centimeters, millimeters).</li>
                <li><strong>Memory Functions:</strong> Basic memory storage (MR, MC, M+).</li>
                <li><strong>Calculation Tape:</strong> Scrollable history tape shows recent calculations.</li>
                <li><strong>Keyboard shortcust:</strong> Keyboard shortcuts are shown next to the functions in perntacies.</li>
            </ul>
            <h2>Usage</h2>
            <ol>
                <li>Download or clone the repository or access through link.</li>
                <li>Open the <code>ArchiCalc vXX.html</code> file in your preferred modern web browser (Chrome, Firefox, Safari, Edge).</li>
                <li>Use the calculator interface directly in your browser.</li>
                <li>you can use the browser setting to install as an app on your phone or desktop</li>
                <li>No installation or backend server required.</li>
            </ol>
            <h2>Compatibility</h2>
            <ul>
                <li>Works in all modern desktop and mobile browsers.</li>
                <li>No external dependencies other than Tailwind CSS and Google Fonts (served via CDN).</li>
            </ul>
            <h2>License</h2>
            <p>Copyright © 2025 Alen Moghaddam</p>
            <p>This software is provided for personal, non-commercial use only.</p>
            <p>Permission is granted to:</p>
            <ul>
                <li>Use the calculator for private or educational architectural purposes.</li>
                <li>Modify the code for your own local use.</li>
            </ul>
            <p>You are not permitted to:</p>
            <ul>
                <li>Redistribute or sell this software or derivative works.</li>
                <li>Use it in any commercial, public-facing, or client-serving application.</li>
                <li>Host the calculator publicly without prior written permission from the author.</li>
            </ul>
            <p>This software is provided "AS IS", without warranty of any kind, express or implied. This includes but is not limited to the implied warranties of merchantability, fitness for a particular purpose, and non-infringement.</p>
            <p><strong>Disclaimer:</strong> The author shall not be held liable for any damages or consequences arising from the use or misuse of this calculator. All calculations should be independently verified before use in professional or regulatory contexts. This tool is not certified for use in code-compliant design, engineering, or life-safety-critical applications.</p>
            <h2>Contributions</h2>
            <p>This is a closed project made available for individual use. Bug reports or enhancement suggestions are welcome via GitHub issues, but this project does not currently accept public contributions or pull requests.</p>
            <h2>Author</h2>
            <p>Created by Alen Moghaddam<br>alm360@yahoo.com</p>
            <hr>
            </div>
    </div>

    <script>
        // --- DOM Elements ---
        const calculatorElement = document.getElementById('calculator'); // Main calculator div
        const historyTapeElement = document.getElementById('historyTape');
        const displayValueElement = document.getElementById('displayValue');
        const displayDimensionalElement = document.getElementById('displayDimensional');
        const calculatorButtons = document.querySelector('.buttons');
        const infoButton = document.getElementById('info-button');
        const noticeModal = document.getElementById('notice-modal');
        const modalContentElement = noticeModal.querySelector('.modal-content');
        const modalCloseButton = document.getElementById('modal-close-button');
        const darkModeToggleButton = document.getElementById('darkModeToggle');
        const uaiLogo = document.getElementById('uaiLogo');
        const uaiLogoPlaceholder = document.getElementById('uaiLogoPlaceholder');


        // --- Input State Enum ---
        const InputState = { START: 'start', ENTERING_DECIMAL: 'entering_decimal', ENTERING_FEET: 'entering_feet', ENTERING_INCHES: 'entering_inches', DIMENSIONAL_COMPLETE: 'dimensional_complete', ENTERING_NUMERATOR: 'entering_numerator', ENTERING_DENOMINATOR: 'entering_denominator', SHOWING_RESULT: 'showing_result', CONVERSION_PENDING: 'conversion_pending' };

        // --- Calculator State Variables ---
        let currentInput = '0'; 
        let displayShouldClear = false; 
        let firstOperand = null; 
        let firstOperandUnitType = 'linear'; 
        let firstOperandWasDimensional = false; 
        let operator = null; 
        let operatorSymbol = ''; 
        let memoryValue = 0; 
        let history = []; 
        const MAX_HISTORY_ITEMS = 10; 
        let resultUnitType = 'linear'; 
        let inputState = InputState.START; 
        let storedFeet = null; 
        let storedInches = null; 
        let storedNumerator = null; 
        let storedDenominator = null; 
        let conversionSourceInfo = { type: null, baseUnit: null }; 
        let currentInputIsDimensional = false; 

        // --- Conversion Factors & Units (unchanged) ---
        const conversionFactors = { 'in': 1, 'ft': 12, 'yd': 36, 'm': 39.3701, 'cm': 0.393701, 'mm': 0.0393701 };
        const areaConversionFactors = { 'sq in': 1, 'sq ft': 144, 'sq yd': 1296, 'sq m': 1550.0031, 'sq cm': 0.15500031, 'sq mm': 0.0015500031 };
        const volumeConversionFactors = { 'cu in': 1, 'cu ft': 1728, 'cu yd': 46656, 'cu m': 61023.744, 'cu cm': 0.061023744, 'cu mm': 0.000061023744 };
        const unitMap = { 'in': { area: 'sq in', volume: 'cu in' }, 'ft': { area: 'sq ft', volume: 'cu ft' }, 'yd': { area: 'sq yd', volume: 'cu yd' }, 'm': { area: 'sq m', volume: 'cu m' }, 'cm': { area: 'sq cm', volume: 'cu cm' }, 'mm': { area: 'sq mm', volume: 'cu mm' } };
        const displayUnits = { 'in': 'in', 'ft': 'ft', 'yd': 'yd', 'm': 'm', 'cm': 'cm', 'mm': 'mm', 'sq in': 'sq in', 'sq ft': 'sq ft', 'sq yd': 'sq yd', 'sq m': 'sq m', 'sq cm': 'sq cm', 'sq mm': 'sq mm', 'cu in': 'cu in', 'cu ft': 'cu ft', 'cu yd': 'cu yd', 'cu m': 'cu m', 'cu cm': 'cu cm', 'cu mm': 'cu mm' };
        const FRACTION_DENOMINATOR_LIMIT = 64; 
        const DISPLAY_DECIMAL_PLACES = 5; 

        // --- Utility Functions (gcd, resetDimensionalInput, etc. - unchanged) ---
        function gcd(a, b) { a = Math.abs(Math.round(a)); b = Math.abs(Math.round(b)); while (b) { [a, b] = [b, a % b]; } return a; }
        function resetDimensionalInput() { storedFeet = null; storedInches = null; storedNumerator = null; storedDenominator = null; currentInputIsDimensional = false; }
        function resetConversionState() { conversionSourceInfo = { type: null, baseUnit: null }; }
        function resetCalculatorStateFull() { currentInput = '0'; firstOperand = null; firstOperandWasDimensional = false; firstOperandUnitType = 'linear'; operator = null; operatorSymbol = ''; displayShouldClear = false; resetDimensionalInput(); resetConversionState(); inputState = InputState.START; displayDimensionalElement.classList.remove('flashing'); history = []; updateHistoryDisplay(); resultUnitType = 'linear'; }
        function resetCalculatorStateExceptHistory() { currentInput = '0'; firstOperand = null; firstOperandWasDimensional = false; firstOperandUnitType = 'linear'; operator = null; operatorSymbol = ''; displayShouldClear = false; resetDimensionalInput(); resetConversionState(); inputState = InputState.START; displayDimensionalElement.classList.remove('flashing'); resultUnitType = 'linear'; }
        function getDimensionalValueInches() { let totalInches = 0; if (storedFeet !== null) totalInches += storedFeet * 12; if (storedInches !== null) totalInches += storedInches; let num = storedNumerator; let den = storedDenominator; if (inputState === InputState.ENTERING_NUMERATOR) { num = parseInt(currentInput); return (storedFeet !== null ? storedFeet * 12 : 0) + (storedInches !== null ? storedInches : 0); } else if (inputState === InputState.ENTERING_DENOMINATOR) { den = parseInt(currentInput); } if (num !== null && den !== null && den !== 0) { totalInches += num / den; } else if (num !== null && den === 0) { return NaN; } return totalInches; }
        function formatInchesToDimensional(totalInches) { if (isNaN(totalInches)) return "Error"; if (!isFinite(totalInches)) return "Infinity"; const sign = totalInches < 0 ? "-" : ""; totalInches = Math.abs(totalInches); const feet = Math.floor(totalInches / 12); const remainingInches = totalInches % 12; const inches = Math.floor(remainingInches); const fractionalPart = remainingInches - inches; let fractionStr = ""; if (fractionalPart > 1e-9) { let bestNumerator = Math.round(fractionalPart * FRACTION_DENOMINATOR_LIMIT); let bestDenominator = FRACTION_DENOMINATOR_LIMIT; if (bestNumerator > 0) { const commonDivisor = gcd(bestNumerator, bestDenominator); if (bestDenominator / commonDivisor > 0) { fractionStr = `${bestNumerator / commonDivisor}/${bestDenominator / commonDivisor}`; } else if (bestNumerator / commonDivisor > 0) { fractionStr = `${bestNumerator / commonDivisor}`; } } } let parts = []; if (feet > 0) parts.push(`${feet} ft`); let inchesPartStr = ''; if (inches > 0 || (feet === 0 && fractionStr)) { inchesPartStr = `${inches}`; } if (fractionStr) { if (inchesPartStr) { inchesPartStr += ` ${fractionStr}`; } else { inchesPartStr = fractionStr; } } if (inchesPartStr || (feet === 0 && inches === 0 && !fractionStr && totalInches === 0)) { if (inchesPartStr) { parts.push(inchesPartStr); parts.push('in'); } else if (totalInches === 0) { parts.push('0 in'); } } const formattedString = sign + parts.join(' ').trim(); return formattedString === "" ? "0 in" : formattedString; }
        function formatAreaDisplay(totalSqInches) { if (isNaN(totalSqInches)) return "Error"; if (!isFinite(totalSqInches)) return "Infinity"; const sign = totalSqInches < 0 ? "-" : ""; totalSqInches = Math.abs(totalSqInches); const sqFeetValue = totalSqInches / areaConversionFactors['sq ft']; const formattedSqFeet = formatDisplayNumber(String(sqFeetValue)); const formattedSqInches = formatDisplayNumber(String(totalSqInches)); return { main: `${sign}${formattedSqFeet} sq ft`, dimensional: `${sign}${formattedSqInches} sq in` }; }
        function formatVolumeDisplay(totalCuInches) { if (isNaN(totalCuInches)) return "Error"; if (!isFinite(totalCuInches)) return "Infinity"; const sign = totalCuInches < 0 ? "-" : ""; totalCuInches = Math.abs(totalCuInches); const cuFeetValue = totalCuInches / volumeConversionFactors['cu ft']; const formattedCuFeet = formatDisplayNumber(String(cuFeetValue)); const formattedSqInches = formatDisplayNumber(String(totalCuInches)); return { main: `${sign}${formattedCuFeet} cu ft`, dimensional: `${sign}${formattedSqInches} cu in` }; }
        function formatCurrentDimensionalInput() { let parts = []; if (storedFeet !== null) parts.push(`${storedFeet} ft`); if (storedInches !== null) parts.push(`${storedInches}`); if (inputState === InputState.ENTERING_NUMERATOR) { let fractionPreview = `${currentInput}`; displayDimensionalElement.classList.add('flashing'); if(storedInches !== null && parts.length > 0 && !parts[parts.length-1].includes('ft')) { parts[parts.length - 1] += ` ${fractionPreview}`; } else { parts.push(fractionPreview); } if (!parts.some(part => part.includes(' in'))) parts.push('in'); } else if (inputState === InputState.ENTERING_DENOMINATOR) { let fractionPreview = `${storedNumerator}/${currentInput}`; displayDimensionalElement.classList.add('flashing'); if(storedInches !== null && parts.length > 0 && !parts[parts.length-1].includes('ft')) { parts[parts.length - 1] += ` ${fractionPreview}`; } else { parts.push(fractionPreview); } if (!parts.some(part => part.includes(' in'))) parts.push('in'); } else if (storedNumerator !== null && storedDenominator !== null) { const commonDivisor = gcd(storedNumerator, storedDenominator); let fractionPreview = `${storedNumerator / commonDivisor}/${storedDenominator / commonDivisor}`; if(storedInches !== null && parts.length > 0 && !parts[parts.length-1].includes('ft')) { parts[p.length - 1] += ` ${fractionPreview}`; } else { parts.push(fractionPreview); } if (!parts.some(part => part.includes(' in'))) parts.push('in'); } else if (storedInches !== null && !parts.some(part => part.includes(' in'))) { parts.push('in'); } if (inputState !== InputState.ENTERING_NUMERATOR && inputState !== InputState.ENTERING_DENOMINATOR) { displayDimensionalElement.classList.remove('flashing'); } return parts.join(' '); }
        function finalizeDimensionalInput() { let totalInches = NaN; if (currentInputIsDimensional) { totalInches = getDimensionalValueInches(); } return totalInches; }
        
        // --- Display Update Functions (updateDisplay, updateHistoryDisplay, etc. - updateDisplay modified slightly for dark mode context) ---
        function updateDisplay() {
            let mainDisplayValue = formatDisplayNumber(currentInput);
            let dimensionalDisplayValue = '';
            displayDimensionalElement.classList.remove('flashing'); 

            if (inputState === InputState.SHOWING_RESULT) {
                const resultValue = parseFloat(currentInput);
                if (conversionSourceInfo.type && displayUnits[conversionSourceInfo.type]) {
                    const targetUnitKey = conversionSourceInfo.type;
                    if (targetUnitKey.startsWith('sq')) { 
                        const valueInTargetUnit = resultValue;
                        mainDisplayValue = `${formatDisplayNumber(String(valueInTargetUnit))} ${displayUnits[targetUnitKey]}`;
                        if (targetUnitKey === 'sq ft') { 
                            const valueInSqIn = valueInTargetUnit * areaConversionFactors['sq ft'];
                            dimensionalDisplayValue = `${formatDisplayNumber(String(valueInSqIn))} sq in`;
                        } else if (targetUnitKey === 'sq in') { 
                            const valueInSqFt = valueInTargetUnit / areaConversionFactors['sq ft'];
                            dimensionalDisplayValue = `${formatDisplayNumber(String(valueInSqFt))} sq ft`;
                        } else { 
                            const valueInSqIn = valueInTargetUnit * areaConversionFactors[targetUnitKey]; 
                            dimensionalDisplayValue = `${formatDisplayNumber(String(valueInSqIn))} sq in`;
                        }
                    } else if (targetUnitKey.startsWith('cu')) { 
                        const valueInTargetUnit = resultValue;
                        mainDisplayValue = `${formatDisplayNumber(String(valueInTargetUnit))} ${displayUnits[targetUnitKey]}`;
                        if (targetUnitKey === 'cu ft') {
                            const valueInCuIn = valueInTargetUnit * volumeConversionFactors['cu ft'];
                            dimensionalDisplayValue = `${formatDisplayNumber(String(valueInCuIn))} cu in`;
                        } else if (targetUnitKey === 'cu in') {
                            const valueInCuFt = valueInTargetUnit / volumeConversionFactors['cu ft'];
                            dimensionalDisplayValue = `${formatDisplayNumber(String(valueInCuFt))} cu ft`;
                        } else {
                            const valueInCuIn = valueInTargetUnit * volumeConversionFactors[targetUnitKey];
                            dimensionalDisplayValue = `${formatDisplayNumber(String(valueInCuIn))} cu in`;
                        }
                    } else { // Linear
                        const lengthInTargetUnit = resultValue;
                        const lengthInBaseInches = lengthInTargetUnit * conversionFactors[targetUnitKey]; 
                        mainDisplayValue = `${formatDisplayNumber(String(lengthInTargetUnit))} ${displayUnits[targetUnitKey]}`;
                        dimensionalDisplayValue = formatInchesToDimensional(lengthInBaseInches);
                    }
                } else if (resultUnitType === 'volume') {
                    const volDisplay = formatVolumeDisplay(resultValue); 
                    mainDisplayValue = volDisplay.main;
                    dimensionalDisplayValue = volDisplay.dimensional;
                } else if (resultUnitType === 'area') {
                    const areaDisplay = formatAreaDisplay(resultValue); 
                    mainDisplayValue = areaDisplay.main;
                    dimensionalDisplayValue = areaDisplay.dimensional;
                } else if (resultUnitType === 'linear' && firstOperandWasDimensional) {
                    mainDisplayValue = formatInchesToDimensional(resultValue); 
                    dimensionalDisplayValue = formatDisplayNumber(String(resultValue)); 
                } else {
                    dimensionalDisplayValue = '';
                }
            } else if (inputState === InputState.CONVERSION_PENDING) {
                let valueToConvertFormatted = formatDisplayNumber(String(firstOperand)); 
                if (conversionSourceInfo.type === 'area') {
                    valueToConvertFormatted = formatAreaDisplay(firstOperand).main;
                } else if (conversionSourceInfo.type === 'volume') {
                    valueToConvertFormatted = formatVolumeDisplay(firstOperand).main;
                } else if (conversionSourceInfo.type === 'linear') {
                    valueToConvertFormatted = formatInchesToDimensional(firstOperand);
                }
                dimensionalDisplayValue = `Conv ${valueToConvertFormatted} → ?`;
                mainDisplayValue = formatDisplayNumber(String(firstOperand)); 
            } else if (currentInputIsDimensional || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) {
                dimensionalDisplayValue = formatCurrentDimensionalInput();
                mainDisplayValue = (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) ? currentInput : formatDisplayNumber(currentInput);
            } else if (conversionSourceInfo.type === 'linear' && conversionSourceInfo.baseUnit && displayUnits[conversionSourceInfo.baseUnit] && inputState !== InputState.ENTERING_DECIMAL) {
                dimensionalDisplayValue = `${mainDisplayValue} ${displayUnits[conversionSourceInfo.baseUnit]}`;
            }

            displayValueElement.textContent = mainDisplayValue;
            displayDimensionalElement.textContent = dimensionalDisplayValue;
        }
        function updateHistoryDisplay() {
            historyTapeElement.innerHTML = ''; 
            for (let i = 0; i < history.length; i++) {
                const historyItemDiv = document.createElement('div');
                historyItemDiv.classList.add('history-item');
                historyItemDiv.innerHTML = history[i]; 
                historyTapeElement.appendChild(historyItemDiv);
            }
            historyTapeElement.scrollTop = historyTapeElement.scrollHeight; 
        }
        function addHistoryEntry(entry) { console.log("addHistoryEntry:", entry); history.push(entry); if (history.length > MAX_HISTORY_ITEMS) { history.shift(); } updateHistoryDisplay(); }
        function clearHistory() { console.log("clearHistory: Clear Tape pressed"); history = []; updateHistoryDisplay(); }
        function formatDisplayNumber(valueStr) { const errorMessages = ['Error', 'Set Unit', 'Cannot Add/Sub Area', 'Cannot Add/Sub L & A', 'Cannot Conv Area', 'Cannot Conv Volume', 'Cannot Add/Sub Volume', 'Cannot Add/Sub A & V', 'Cannot Add/Sub L & V', 'Cannot Mult V & L', 'Cannot Div by Zero']; if (errorMessages.includes(valueStr)) { return valueStr; } const maxLength = 12; let hasTrailingDecimal = valueStr.endsWith('.'); let displayStr = valueStr; if (hasTrailingDecimal) { displayStr = valueStr.slice(0, -1); } const numericValue = parseFloat(displayStr); if (isNaN(numericValue)) { return (displayStr === '0' || displayStr === '') ? '0' : 'Error'; } let formattedNumber; if (Math.abs(numericValue) > 1e12 || (Math.abs(numericValue) < 1e-6 && numericValue !== 0)) { formattedNumber = numericValue.toExponential(maxLength - 6); } else { let roundedValueStr; if (displayStr.includes('.')) { roundedValueStr = numericValue.toFixed(DISPLAY_DECIMAL_PLACES); roundedValueStr = roundedValueStr.replace(/0+$/, '').replace(/\.$/, ''); } else { roundedValueStr = displayStr; } const parts = roundedValueStr.split('.'); parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","); formattedNumber = parts.join('.'); } if (hasTrailingDecimal && !formattedNumber.includes('.') && !formattedNumber.toLowerCase().includes('e')) { formattedNumber += '.'; } return formattedNumber.slice(0, maxLength); }

        // --- Input Handling Functions (inputDigit, inputDecimal, etc. - unchanged) ---
        function inputDigit(digit) { if (inputState === InputState.SHOWING_RESULT) { resetCalculatorStateExceptHistory(); currentInput = digit; inputState = InputState.START; updateDisplay(); return; } if (inputState === InputState.DIMENSIONAL_COMPLETE) { if (storedInches !== null) { inputState = InputState.ENTERING_NUMERATOR; currentInput = digit; displayShouldClear = false; currentInputIsDimensional = true; updateDisplay(); return; } else { resetCalculatorStateExceptHistory(); currentInput = digit; inputState = InputState.START; updateDisplay(); return; } } if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) { if (currentInput === '0' && digit === '0') return; currentInput = currentInput === '0' ? digit : currentInput + digit; updateDisplay(); return; } if (displayShouldClear) { currentInput = '0'; displayShouldClear = false; if (inputState !== InputState.ENTERING_INCHES && inputState !== InputState.ENTERING_NUMERATOR && inputState !== InputState.ENTERING_DENOMINATOR && inputState !== InputState.DIMENSIONAL_COMPLETE) { resetDimensionalInput(); resetConversionState(); inputState = InputState.START; } } if (currentInput === '0' && digit === '0') return; currentInput = currentInput === '0' ? digit : currentInput + digit; if (inputState === InputState.START) { inputState = InputState.ENTERING_FEET; } updateDisplay(); }
        function inputDecimal() { if (inputState === InputState.SHOWING_RESULT) { resetCalculatorStateExceptHistory(); currentInput = '0.'; inputState = InputState.ENTERING_DECIMAL; updateDisplay(); return; } if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) { return; } if (displayShouldClear) { currentInput = '0.'; displayShouldClear = false; resetDimensionalInput(); resetConversionState(); inputState = InputState.ENTERING_DECIMAL; updateDisplay(); return; } if (!currentInput.includes('.')) { if (inputState === InputState.DIMENSIONAL_COMPLETE) { resetDimensionalInput(); resetConversionState(); currentInput = '0.'; inputState = InputState.ENTERING_DECIMAL; } else { currentInput += '.'; if (inputState === InputState.START || inputState === InputState.ENTERING_FEET) { inputState = InputState.ENTERING_DECIMAL; } else if (inputState === InputState.ENTERING_INCHES) { inputState = InputState.ENTERING_DECIMAL; } } updateDisplay(); } }
        function performCalculation(op1, op1Type, op1WasDim, op2, op2Type, op2WasDim, operation) { console.log(`performCalculation: op1=${op1} (${op1Type}, dim:${op1WasDim}), op2=${op2} (${op2Type}, dim:${op2WasDim}), operation=${operation}`); if (op1 === null || isNaN(op1) || isNaN(op2)) { return { value: NaN, unitType: 'linear', error: 'Invalid Operand' }; } let resultValue = 0; let resultUnitTypeCalc = 'linear'; const op1IsNumeric = (op1Type === 'linear' && !op1WasDim); const op2IsNumeric = (op2Type === 'linear' && !op2WasDim); if (operation === 'add' || operation === 'subtract') { if (op1Type !== op2Type) { return { value: NaN, unitType: 'linear', error: `Cannot Add/Sub ${op1Type} & ${op2Type}` }; } resultUnitTypeCalc = op1Type; } else if (operation === 'multiply') { if (op1Type === 'linear' && op2Type === 'linear') { resultUnitTypeCalc = (op1IsNumeric && op2IsNumeric) ? 'linear' : (op1IsNumeric || op2IsNumeric) ? 'linear' : 'area'; } else if ((op1Type === 'area' && op2Type === 'linear') || (op1Type === 'linear' && op2Type === 'area')) { const linearOperandIsNumeric = (op1Type === 'linear' ? op1IsNumeric : op2IsNumeric); resultUnitTypeCalc = linearOperandIsNumeric ? 'area' : 'volume'; } else if ((op1Type === 'volume' && op2Type === 'linear') || (op1Type === 'linear' && op2Type === 'volume')) { const linearOperandIsNumeric = (op1Type === 'linear' ? op1IsNumeric : op2IsNumeric); if (linearOperandIsNumeric) resultUnitTypeCalc = 'volume'; else return { value: NaN, unitType: 'linear', error: (op1Type === 'volume' ? "Cannot Mult V & L" : "Cannot Mult L & V") }; } else if (op1Type === 'area' && op2Type === 'area') { return { value: NaN, unitType: 'linear', error: "Cannot Mult A & A"}; } else if (op1Type === 'volume' && op2Type === 'volume') { return { value: NaN, unitType: 'linear', error: "Cannot Mult V & V"}; } else { return { value: NaN, unitType: 'linear', error: `Cannot Mult ${op1Type} & ${op2Type}` }; } } else if (operation === 'divide') { if (op2 === 0) { return { value: NaN, unitType: 'linear', error: "Cannot Div by Zero" }; } if (op1Type === 'linear' && op2Type === 'linear') { resultUnitTypeCalc = 'linear'; } else if (op1Type === 'area' && op2Type === 'linear') { resultUnitTypeCalc = op2IsNumeric ? 'area' : 'linear'; } else if (op1Type === 'volume' && op2Type === 'linear') { resultUnitTypeCalc = op2IsNumeric ? 'volume' : 'area'; } else if (op1Type === 'volume' && op2Type === 'area') { resultUnitTypeCalc = 'linear'; } else if (op1Type === 'linear' && (op2Type === 'area' || op2Type === 'volume')) { return { value: NaN, unitType: 'linear', error: `Cannot Div L by ${op2Type}` }; } else if (op1Type === 'area' && op2Type === 'volume') { return { value: NaN, unitType: 'linear', error: "Cannot Div A by V" }; } else { resultUnitTypeCalc = 'linear'; } } switch (operation) { case 'add': resultValue = op1 + op2; break; case 'subtract': resultValue = op1 - op2; break; case 'multiply': resultValue = op1 * op2; break; case 'divide': resultValue = op1 / op2; break; default: console.warn("Unknown operation:", operation); return { value: op2, unitType: op2Type }; } console.log(`performCalculation: Result = ${resultValue} (${resultUnitTypeCalc})`); return { value: resultValue, unitType: resultUnitTypeCalc }; }
        function handleOperator(newOperator) { let inputValue; let inputUnitType = 'linear'; let inputWasDimensional = false; const operatorSymbols = { 'add': '+', 'subtract': '−', 'multiply': '×', 'divide': '÷' }; const newOperatorSymbol = operatorSymbols[newOperator] || ''; if (inputState === InputState.SHOWING_RESULT) { firstOperand = parseFloat(currentInput); firstOperandUnitType = resultUnitType; operator = newOperator; operatorSymbol = newOperatorSymbol; let historyOperandDisplay; if (firstOperandUnitType === 'volume') historyOperandDisplay = formatVolumeDisplay(firstOperand).main; else if (firstOperandUnitType === 'area') historyOperandDisplay = formatAreaDisplay(firstOperand).main; else if (firstOperandWasDimensional) historyOperandDisplay = formatInchesToDimensional(firstOperand); else historyOperandDisplay = formatDisplayNumber(String(firstOperand)); addHistoryEntry(`${historyOperandDisplay} ${operatorSymbol}`); displayShouldClear = true; inputState = InputState.START; resetConversionState(); resetDimensionalInput(); return; } if (inputState === InputState.ENTERING_INCHES) { const inchesVal = parseFloat(currentInput); if (!isNaN(inchesVal)) { storedInches = inchesVal; } inputValue = finalizeDimensionalInput(); inputUnitType = 'linear'; inputWasDimensional = true; resetDimensionalInput(); } else if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE) { inputValue = finalizeDimensionalInput(); inputUnitType = 'linear'; inputWasDimensional = true; resetDimensionalInput(); } else if (conversionSourceInfo.type === 'linear' && conversionSourceInfo.baseUnit) { inputValue = parseFloat(currentInput) * conversionFactors[conversionSourceInfo.baseUnit]; inputUnitType = 'linear'; inputWasDimensional = true; resetConversionState(); } else { inputValue = parseFloat(currentInput); inputUnitType = 'linear'; inputWasDimensional = false; resetConversionState(); } if (isNaN(inputValue)) { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; updateDisplay(); return; } if (operator && !displayShouldClear) { if (firstOperand === null) { firstOperand = inputValue; firstOperandUnitType = inputUnitType; firstOperandWasDimensional = inputWasDimensional; } else { const calcResult = performCalculation( firstOperand, firstOperandUnitType, firstOperandWasDimensional, inputValue, inputUnitType, inputWasDimensional, operator ); if (calcResult.error) { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; displayDimensionalElement.textContent = calcResult.error; setTimeout(() => { updateDisplay(); }, 1500); updateDisplay(); return; } if (isNaN(calcResult.value)) { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; updateDisplay(); return; } firstOperand = calcResult.value; firstOperandUnitType = calcResult.unitType; firstOperandWasDimensional = (calcResult.unitType === 'linear' && (firstOperandWasDimensional || inputWasDimensional)) || calcResult.unitType === 'area' || calcResult.unitType === 'volume'; currentInput = String(firstOperand); resultUnitType = firstOperandUnitType; if (history.length > 0) { let lastEntryIndex = history.length - 1; let secondOperandDisplay = inputWasDimensional ? formatInchesToDimensional(inputValue) : formatDisplayNumber(String(inputValue)); if (history[lastEntryIndex] && history[lastEntryIndex].includes(operatorSymbol) && !history[lastEntryIndex].includes('=')) { history[lastEntryIndex] = `${history[lastEntryIndex]} ${secondOperandDisplay}`; } else { let firstOpDisplay; if (firstOperandUnitType === 'volume') firstOpDisplay = formatVolumeDisplay(firstOperand).main; else if (firstOperandUnitType === 'area') firstOpDisplay = formatAreaDisplay(firstOperand).main; else if (firstOperandWasDimensional) firstOpDisplay = formatInchesToDimensional(firstOperand); else firstOpDisplay = formatDisplayNumber(String(firstOperand)); history[lastEntryIndex] = `${firstOpDisplay}`; } updateHistoryDisplay(); } } } else { firstOperand = inputValue; firstOperandUnitType = inputUnitType; firstOperandWasDimensional = inputWasDimensional; let historyOperandDisplay; if (firstOperandUnitType === 'volume') historyOperandDisplay = formatVolumeDisplay(firstOperand).main; else if (firstOperandUnitType === 'area') historyOperandDisplay = formatAreaDisplay(firstOperand).main; else if (firstOperandWasDimensional) historyOperandDisplay = formatInchesToDimensional(firstOperand); else historyOperandDisplay = formatDisplayNumber(String(firstOperand)); addHistoryEntry(`${historyOperandDisplay} ${newOperatorSymbol}`); } operator = newOperator; operatorSymbol = newOperatorSymbol; displayShouldClear = true; inputState = InputState.START; resetDimensionalInput(); resetConversionState(); }
        function handleEquals() { if (!operator || firstOperand === null) { if (inputState === InputState.ENTERING_INCHES) { const inchesVal = parseFloat(currentInput); if (!isNaN(inchesVal)) { storedInches = inchesVal; } const finalVal = finalizeDimensionalInput(); if (!isNaN(finalVal)) { currentInput = String(finalVal); firstOperandWasDimensional = true; resultUnitType = 'linear'; conversionSourceInfo = { type: 'linear', baseUnit: 'in' }; inputState = InputState.SHOWING_RESULT; resetDimensionalInput(); updateDisplay(); return; } } else if (inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) { const finalVal = finalizeDimensionalInput(); if (!isNaN(finalVal)) { currentInput = String(finalVal); firstOperandWasDimensional = true; resultUnitType = 'linear'; conversionSourceInfo = { type: 'linear', baseUnit: 'in' }; inputState = InputState.SHOWING_RESULT; resetDimensionalInput(); updateDisplay(); return; } } else if (conversionSourceInfo.type === 'linear' && conversionSourceInfo.baseUnit) { inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; firstOperandWasDimensional = true; updateDisplay(); return; } if (!isNaN(parseFloat(currentInput)) && inputState !== InputState.START) { /* Do nothing or finalize */ } else { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; updateDisplay(); return; } } let secondOperandValue; let secondOperandUnitType = 'linear'; let secondOperandWasDimensional = false; if (inputState === InputState.ENTERING_INCHES) { const inchesVal = parseFloat(currentInput); if (!isNaN(inchesVal)) { storedInches = inchesVal; } secondOperandValue = finalizeDimensionalInput(); secondOperandUnitType = 'linear'; secondOperandWasDimensional = true; resetDimensionalInput(); } else if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE) { secondOperandValue = finalizeDimensionalInput(); secondOperandUnitType = 'linear'; secondOperandWasDimensional = true; resetDimensionalInput(); } else if (conversionSourceInfo.type === 'linear' && conversionSourceInfo.baseUnit) { secondOperandValue = parseFloat(currentInput) * conversionFactors[conversionSourceInfo.baseUnit]; secondOperandUnitType = 'linear'; secondOperandWasDimensional = true; resetConversionState(); } else { secondOperandValue = parseFloat(currentInput); secondOperandUnitType = 'linear'; secondOperandWasDimensional = false; resetConversionState(); } if (isNaN(secondOperandValue)) { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; updateDisplay(); return; } const calcResult = performCalculation( firstOperand, firstOperandUnitType, firstOperandWasDimensional, secondOperandValue, secondOperandUnitType, secondOperandWasDimensional, operator ); if (calcResult.error) { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; displayDimensionalElement.textContent = calcResult.error; setTimeout(() => { updateDisplay(); }, 1500); updateDisplay(); return; } if (isNaN(calcResult.value)) { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; updateDisplay(); return; } currentInput = String(calcResult.value); resultUnitType = calcResult.unitType; firstOperandWasDimensional = (resultUnitType === 'linear' && (firstOperandWasDimensional || secondOperandWasDimensional)) || resultUnitType === 'area' || resultUnitType === 'volume'; resetConversionState(); const originalInputStateForHistory = inputState; inputState = InputState.SHOWING_RESULT; if (history.length > 0) { let lastEntryIndex = history.length - 1; let resultDisplay; if (resultUnitType === 'volume') { resultDisplay = formatVolumeDisplay(calcResult.value).main; } else if (resultUnitType === 'area') { resultDisplay = formatAreaDisplay(calcResult.value).main; } else if (resultUnitType === 'linear' && firstOperandWasDimensional) { resultDisplay = formatInchesToDimensional(calcResult.value); } else { resultDisplay = formatDisplayNumber(String(calcResult.value)); } let secondOperandDisplayForHistory = secondOperandWasDimensional ? formatInchesToDimensional(secondOperandValue) : formatDisplayNumber(String(secondOperandValue)); if (history[lastEntryIndex] && history[lastEntryIndex].includes(operatorSymbol) && !history[lastEntryIndex].includes('=')) { history[lastEntryIndex] = `${history[lastEntryIndex]} ${secondOperandDisplayForHistory} = <strong>${resultDisplay}</strong>`; } else { let firstOperandDisplayForHistory; if (firstOperandUnitType === 'volume') firstOperandDisplayForHistory = formatVolumeDisplay(firstOperand).main; else if (firstOperandUnitType === 'area') firstOperandDisplayForHistory = formatAreaDisplay(firstOperand).main; else if (firstOperandWasDimensional && firstOperandUnitType === 'linear') firstOperandDisplayForHistory = formatInchesToDimensional(firstOperand); else firstOperandDisplayForHistory = formatDisplayNumber(String(firstOperand)); addHistoryEntry(`${firstOperandDisplayForHistory} ${operatorSymbol} ${secondOperandDisplayForHistory} = <strong>${resultDisplay}</strong>`); } updateHistoryDisplay(); } operator = null; operatorSymbol = ''; firstOperand = null; displayShouldClear = true; resetDimensionalInput(); inputState = InputState.SHOWING_RESULT; console.log(`handleEquals: Final result=${currentInput} (${resultUnitType}), firstOperandWasDimensional=${firstOperandWasDimensional}, inputState=${inputState}`); updateDisplay(); }
        function clearCalculator() { console.log("clearCalculator: On/C pressed"); resetCalculatorStateExceptHistory(); addHistoryEntry('------'); updateDisplay(); }
        function handleUnit(unitKey) { console.log(`handleUnit: ${unitKey}, State: ${inputState}, currentInput: ${currentInput}, resultUnitType: ${resultUnitType}, conversionSourceInfo:`, conversionSourceInfo); if (inputState === InputState.CONVERSION_PENDING && conversionSourceInfo.type) { let valueInBaseUnits = firstOperand; let targetUnitFullName = null; let conversionFactorsTable = null; let newResultUnitType = conversionSourceInfo.type; if (conversionSourceInfo.type === 'area') { targetUnitFullName = unitMap[unitKey]?.area; conversionFactorsTable = areaConversionFactors; if (!targetUnitFullName || !conversionFactorsTable[targetUnitFullName]) { displayDimensionalElement.textContent = "Invalid Area Unit"; setTimeout(() => { updateDisplay(); }, 1500); inputState = InputState.SHOWING_RESULT; currentInput = String(firstOperand); resultUnitType = 'area'; resetConversionState(); firstOperand = null; updateDisplay(); return; } } else if (conversionSourceInfo.type === 'volume') { targetUnitFullName = unitMap[unitKey]?.volume; conversionFactorsTable = volumeConversionFactors; if (!targetUnitFullName || !conversionFactorsTable[targetUnitFullName]) { displayDimensionalElement.textContent = "Invalid Volume Unit"; setTimeout(() => { updateDisplay(); }, 1500); inputState = InputState.SHOWING_RESULT; currentInput = String(firstOperand); resultUnitType = 'volume'; resetConversionState(); firstOperand = null; updateDisplay(); return; } } else { targetUnitFullName = unitKey; conversionFactorsTable = conversionFactors; if (!conversionFactorsTable[targetUnitFullName]) { displayDimensionalElement.textContent = "Invalid Unit"; setTimeout(() => { updateDisplay(); }, 1500); inputState = InputState.SHOWING_RESULT; currentInput = String(firstOperand); resultUnitType = 'linear'; resetConversionState(); firstOperand = null; updateDisplay(); return; } } const targetUnitFactor = conversionFactorsTable[targetUnitFullName]; const resultInTargetUnit = valueInBaseUnits / targetUnitFactor; let fromFormattedString; if (conversionSourceInfo.type === 'area') fromFormattedString = formatAreaDisplay(valueInBaseUnits).main; else if (conversionSourceInfo.type === 'volume') fromFormattedString = formatVolumeDisplay(valueInBaseUnits).main; else fromFormattedString = formatInchesToDimensional(valueInBaseUnits); const toFormattedString = `${formatDisplayNumber(String(resultInTargetUnit))} ${displayUnits[targetUnitFullName]}`; addHistoryEntry(`Conv ${fromFormattedString} → <strong>${toFormattedString}</strong>`); currentInput = String(resultInTargetUnit); resultUnitType = newResultUnitType; firstOperandWasDimensional = false; conversionSourceInfo = { type: targetUnitFullName, baseUnit: null }; inputState = InputState.SHOWING_RESULT; firstOperand = null; displayShouldClear = true; resetDimensionalInput(); updateDisplay(); return; } if (inputState === InputState.SHOWING_RESULT) { const resultValue = parseFloat(currentInput); const resultIsDimensionalLinear = (resultUnitType === 'linear' && firstOperandWasDimensional); if ((resultUnitType === 'area' || resultUnitType === 'volume') && unitKey !== 'Conv') { return; } if (resultUnitType === 'linear' && conversionFactors[unitKey]) { let valueInBaseInches; if (resultIsDimensionalLinear) { valueInBaseInches = resultValue; } else if (conversionSourceInfo.type && conversionFactors[conversionSourceInfo.type]) { valueInBaseInches = resultValue * conversionFactors[conversionSourceInfo.type]; } else { displayDimensionalElement.textContent = "Use Conv First or input unit"; setTimeout(() => { updateDisplay(); }, 1500); return; } const targetUnitFactor = conversionFactors[unitKey]; const convertedResult = valueInBaseInches / targetUnitFactor; const fromFormatted = formatInchesToDimensional(valueInBaseInches); const toFormatted = `${formatDisplayNumber(String(convertedResult))} ${displayUnits[unitKey]}`; addHistoryEntry(`Conv ${fromFormatted} → <strong>${toFormatted}</strong>`); currentInput = String(convertedResult); conversionSourceInfo = { type: unitKey, baseUnit: null }; firstOperandWasDimensional = false; inputState = InputState.SHOWING_RESULT; resetDimensionalInput(); updateDisplay(); return; } const displayValBeforeReset = formatDisplayNumber(String(resultValue)); resetCalculatorStateExceptHistory(); currentInput = displayValBeforeReset; inputState = InputState.START; } const valueFromDisplay = parseFloat(currentInput); const hasValue = !isNaN(valueFromDisplay) && (currentInput !== '0' || (currentInput === '0' && (inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.ENTERING_NUMERATOR) )); if (unitKey === 'ft') { if (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) { storedFeet = hasValue ? valueFromDisplay : 0; storedInches = 0; inputState = InputState.ENTERING_INCHES; currentInput = '0'; displayShouldClear = true; currentInputIsDimensional = true; resetConversionState(); } else if (inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.ENTERING_INCHES) { const valueToSaveAsFirstOperand = finalizeDimensionalInput(); if(!isNaN(valueToSaveAsFirstOperand)) { firstOperand = valueToSaveAsFirstOperand; firstOperandUnitType = 'linear'; firstOperandWasDimensional = true; operator = null; operatorSymbol = ''; storedFeet = hasValue ? valueFromDisplay : 0; storedInches = 0; storedNumerator = null; storedDenominator = null; currentInput = '0'; inputState = InputState.ENTERING_INCHES; currentInputIsDimensional = true; displayShouldClear = true; resetConversionState(); } } } else if (unitKey === 'in') { if (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) { storedFeet = storedFeet !== null ? storedFeet : 0; storedInches = hasValue ? valueFromDisplay : 0; inputState = InputState.DIMENSIONAL_COMPLETE; currentInput = '0'; displayShouldClear = true; currentInputIsDimensional = true; resetConversionState(); } else if (inputState === InputState.ENTERING_INCHES) { storedInches = hasValue ? valueFromDisplay : 0; inputState = InputState.DIMENSIONAL_COMPLETE; currentInput = '0'; displayShouldClear = true; currentInputIsDimensional = true; resetConversionState(); } else if (inputState === InputState.ENTERING_DENOMINATOR) { const denominatorValue = parseInt(currentInput); if (!isNaN(denominatorValue) && denominatorValue !== 0 && storedNumerator !== null) { storedDenominator = denominatorValue; const finalDimensionalValue = finalizeDimensionalInput(); if (!isNaN(finalDimensionalValue)) { currentInput = String(finalDimensionalValue); firstOperandWasDimensional = true; resultUnitType = 'linear'; conversionSourceInfo = { type: 'linear', baseUnit: 'in' }; inputState = InputState.SHOWING_RESULT; displayShouldClear = true; } } else { return; } } else if (inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_NUMERATOR) { const valueToSaveAsFirstOperand = finalizeDimensionalInput(); if(!isNaN(valueToSaveAsFirstOperand)) { firstOperand = valueToSaveAsFirstOperand; firstOperandUnitType = 'linear'; firstOperandWasDimensional = true; operator = null; operatorSymbol = ''; storedFeet = 0; storedInches = hasValue ? valueFromDisplay : 0; storedNumerator = null; storedDenominator = null; currentInput = '0'; inputState = InputState.DIMENSIONAL_COMPLETE; currentInputIsDimensional = true; displayShouldClear = true; resetConversionState(); } } } else if (conversionFactors[unitKey]) { if (inputState === InputState.START || inputState === InputState.ENTERING_DECIMAL || inputState === InputState.ENTERING_FEET) { resetDimensionalInput(); conversionSourceInfo = { type: 'linear', baseUnit: unitKey }; displayShouldClear = true; } } updateDisplay(); }
        function handleConvert() { let valueToConvertInBaseUnits; let sourceInfoForConversion = { type: null, baseUnit: null }; if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_INCHES) { valueToConvertInBaseUnits = finalizeDimensionalInput(); sourceInfoForConversion = { type: 'linear', baseUnit: 'in' }; resetDimensionalInput(); } else if (inputState === InputState.SHOWING_RESULT) { valueToConvertInBaseUnits = parseFloat(currentInput); if (resultUnitType === 'volume') { sourceInfoForConversion = { type: 'volume', baseUnit: 'cu in' }; } else if (resultUnitType === 'area') { sourceInfoForConversion = { type: 'area', baseUnit: 'sq in' }; } else if (resultUnitType === 'linear') { if (firstOperandWasDimensional) { sourceInfoForConversion = { type: 'linear', baseUnit: 'in' }; } else if (conversionSourceInfo.type && conversionFactors[conversionSourceInfo.type]) { valueToConvertInBaseUnits = valueToConvertInBaseUnits * conversionFactors[conversionSourceInfo.type]; sourceInfoForConversion = { type: 'linear', baseUnit: 'in' }; } else { sourceInfoForConversion = { type: 'linear', baseUnit: 'in' }; } } } else if (conversionSourceInfo.type === 'linear' && conversionSourceInfo.baseUnit) { valueToConvertInBaseUnits = parseFloat(currentInput) * conversionFactors[conversionSourceInfo.baseUnit]; sourceInfoForConversion = { type: 'linear', baseUnit: 'in' }; resetConversionState(); } else if (!isNaN(parseFloat(currentInput))) { valueToConvertInBaseUnits = parseFloat(currentInput); sourceInfoForConversion = { type: 'linear', baseUnit: 'in' }; } else { displayDimensionalElement.textContent = "Set Unit First"; setTimeout(() => { updateDisplay(); }, 1000); return; } if (isNaN(valueToConvertInBaseUnits)) { currentInput = 'Error'; resetCalculatorStateExceptHistory(); inputState = InputState.SHOWING_RESULT; resultUnitType = 'linear'; updateDisplay(); return; } inputState = InputState.CONVERSION_PENDING; firstOperand = valueToConvertInBaseUnits; conversionSourceInfo = sourceInfoForConversion; displayShouldClear = true; resetDimensionalInput(); updateDisplay(); }
        function handleFraction() { console.log(`handleFraction: State: ${inputState}, currentInput: ${currentInput}`); if (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) { const numValue = parseInt(currentInput); if (!isNaN(numValue) && currentInput.indexOf('.') === -1) { console.log("handleFraction: Starting fraction with current input as numerator, assuming 0 ft 0 in."); storedFeet = storedFeet !== null ? storedFeet : 0; storedInches = (storedFeet !== null && storedInches === null) ? 0 : (storedInches !== null ? storedInches : 0) ; storedNumerator = numValue; inputState = InputState.ENTERING_DENOMINATOR; currentInput = '0'; displayShouldClear = true; currentInputIsDimensional = true; updateDisplay(); } else if (currentInput === '0' && (inputState === InputState.START || inputState === InputState.ENTERING_FEET)) { console.log("handleFraction: Starting numerator for 0 ft 0 in X/Y"); storedFeet = storedFeet !== null ? storedFeet : 0; storedInches = storedInches !== null ? storedInches : 0; inputState = InputState.ENTERING_NUMERATOR; currentInput = '0'; displayShouldClear = true; currentInputIsDimensional = true; updateDisplay(); } else { console.warn("handleFraction: Invalid value or state for starting fraction directly."); } } else if (inputState === InputState.ENTERING_INCHES || inputState === InputState.DIMENSIONAL_COMPLETE) { const inchesValue = parseFloat(currentInput); if (inputState === InputState.ENTERING_INCHES) { if (!isNaN(inchesValue)) storedInches = inchesValue; else if (storedInches === null) storedInches = 0; } console.log("handleFraction: Starting numerator entry after inches are set."); inputState = InputState.ENTERING_NUMERATOR; currentInput = '0'; displayShouldClear = true; currentInputIsDimensional = true; updateDisplay(); } else if (inputState === InputState.ENTERING_NUMERATOR) { console.log("handleFraction: Moving to denominator entry."); const numeratorValue = parseInt(currentInput); if (!isNaN(numeratorValue)) { storedNumerator = numeratorValue; inputState = InputState.ENTERING_DENOMINATOR; currentInput = '0'; displayShouldClear = true; updateDisplay(); } else { console.warn("handleFraction: Invalid numerator value."); } } else { console.log("handleFraction: Ignoring fraction button in current state:", inputState); } }
        function memoryClear() { memoryValue = 0; displayDimensionalElement.textContent = "Mem Clear"; setTimeout(() => { updateDisplay(); }, 500); }
        function memoryRecall() { resetCalculatorStateExceptHistory(); currentInput = String(memoryValue); inputState = InputState.SHOWING_RESULT; firstOperandWasDimensional = true; resultUnitType = 'linear'; conversionSourceInfo = { type: 'linear', baseUnit: 'in' }; updateDisplay(); }
        function memoryAdd() { let valueToAddInInches; let valueUnitType = 'linear'; if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_INCHES) { valueToAddInInches = finalizeDimensionalInput(); resetDimensionalInput(); } else if (inputState === InputState.SHOWING_RESULT) { valueToAddInInches = parseFloat(currentInput); valueUnitType = resultUnitType; if (valueUnitType === 'area' || valueUnitType === 'volume') { displayDimensionalElement.textContent = `Cannot M+ ${valueUnitType}`; setTimeout(() => { updateDisplay(); }, 1000); return; } if (resultUnitType === 'linear' && !firstOperandWasDimensional && conversionSourceInfo.type && conversionFactors[conversionSourceInfo.type]) { valueToAddInInches = valueToAddInInches * conversionFactors[conversionSourceInfo.type]; } } else if (conversionSourceInfo.type === 'linear' && conversionSourceInfo.baseUnit) { valueToAddInInches = parseFloat(currentInput) * conversionFactors[conversionSourceInfo.baseUnit]; resetConversionState(); } else { valueToAddInInches = parseFloat(currentInput); } if (!isNaN(valueToAddInInches)) { memoryValue += valueToAddInInches; displayShouldClear = true; inputState = InputState.START; displayDimensionalElement.textContent = "M+"; setTimeout(() => { updateDisplay(); }, 500); currentInput = '0'; updateDisplay(); } }
        function toggleSign() { if ( (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) || (inputState === InputState.SHOWING_RESULT && resultUnitType === 'linear' && !firstOperandWasDimensional && !conversionSourceInfo.type) ) { const numericValue = parseFloat(currentInput); if (!isNaN(numericValue) && numericValue !== 0) { currentInput = String(numericValue * -1); updateDisplay(); } } }
        function handleBackspace() { if (inputState === InputState.SHOWING_RESULT || inputState === InputState.CONVERSION_PENDING) { return; } if (currentInput === '0') { if (inputState === InputState.ENTERING_DENOMINATOR) { currentInput = String(storedNumerator !== null ? storedNumerator : '0'); storedNumerator = null; inputState = InputState.ENTERING_NUMERATOR; displayShouldClear = false; } else if (inputState === InputState.ENTERING_NUMERATOR) { currentInput = String(storedInches !== null ? storedInches : '0'); storedNumerator = null; inputState = InputState.DIMENSIONAL_COMPLETE; displayShouldClear = false; } else if (inputState === InputState.DIMENSIONAL_COMPLETE) { if (storedFeet !== null) { currentInput = String(storedInches !== null ? storedInches : '0'); inputState = InputState.ENTERING_INCHES; } else { currentInput = String(storedInches !== null ? storedInches : '0'); inputState = InputState.ENTERING_FEET; currentInputIsDimensional = false; } displayShouldClear = false; } else if (inputState === InputState.ENTERING_INCHES) { currentInput = String(storedFeet !== null ? storedFeet : '0'); storedFeet = null; storedInches = null; inputState = InputState.ENTERING_FEET; currentInputIsDimensional = false; displayShouldClear = false; } updateDisplay(); return; } if (currentInput.length > 1) { currentInput = currentInput.slice(0, -1); if (!currentInput.includes('.') && inputState === InputState.ENTERING_DECIMAL) { if (/^\d+$/.test(currentInput)) { inputState = InputState.ENTERING_FEET; } } } else { currentInput = '0'; } updateDisplay(); }

        // --- Dark Mode Logic ---
        function setDarkMode(isDark) {
            if (isDark) {
                document.body.classList.add('dark-mode');
                calculatorElement.classList.add('dark-mode');
                // modalContentElement.classList.add('dark-mode'); // Using descendant selector now
                darkModeToggleButton.textContent = '☼'; // Sun icon
                darkModeToggleButton.title = "Toggle Light Mode";
                if (uaiLogo) uaiLogo.style.filter = 'invert(0.9) hue-rotate(180deg) saturate(0.5) brightness(1.2)'; // Adjusted filter for better visibility
            } else {
                document.body.classList.remove('dark-mode');
                calculatorElement.classList.remove('dark-mode');
                // modalContentElement.classList.remove('dark-mode');
                darkModeToggleButton.textContent = '🔅'; // Moon icon
                darkModeToggleButton.title = "Toggle Dark Mode";
                if (uaiLogo) uaiLogo.style.filter = 'none';
            }
        }

        darkModeToggleButton.addEventListener('click', () => {
            const isDarkMode = document.body.classList.contains('dark-mode');
            setDarkMode(!isDarkMode);
            localStorage.setItem('darkMode', !isDarkMode);
        });

        // Load dark mode preference on page load
        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const savedDarkMode = localStorage.getItem('darkMode');

        if (savedDarkMode === 'true') {
            setDarkMode(true);
        } else if (savedDarkMode === 'false') {
            setDarkMode(false);
        } else { // No preference saved, use system preference
            setDarkMode(prefersDark);
        }


        // --- Central Event Listener for Button Clicks (unchanged) ---
        calculatorButtons.addEventListener('click', (event) => {
            const target = event.target.closest('button'); 
            if (!target) return; 
            const action = target.dataset.action;
            const number = target.dataset.number;
            const unit = target.dataset.unit;
            console.log("--- Button Clicked:", { action, number, unit }, "---"); 
            if (number !== undefined) inputDigit(number);
            else if (unit !== undefined) handleUnit(unit);
            else if (action !== undefined) {
                switch (action) {
                    case 'add': case 'subtract': case 'multiply': case 'divide': handleOperator(action); break;
                    case 'decimal': inputDecimal(); break;
                    case 'calculate': handleEquals(); break;
                    case 'clear': clearCalculator(); break;
                    case 'backspace': handleBackspace(); break;
                    case 'convert': handleConvert(); break;
                    case 'fraction': handleFraction(); break;
                    case 'memory-clear': memoryClear(); break;
                    case 'memory-recall': memoryRecall(); break;
                    case 'memory-add': memoryAdd(); break;
                    case 'sign': toggleSign(); break;
                    case 'clear-history': clearHistory(); break;
                    default: console.warn("Unknown action:", action);
                }
            }
        });

        // --- Keyboard Input Listener (unchanged) ---
        window.addEventListener('keydown', (event) => {
            const key = event.key;
            let targetButton = null; 
            if (/[0-9]/.test(key)) targetButton = calculatorButtons.querySelector(`.btn[data-number="${key}"]`);
            else if (key === '.') targetButton = calculatorButtons.querySelector('.btn[data-action="decimal"]');
            else if (key === "'") targetButton = calculatorButtons.querySelector('.btn[data-unit="ft"]');
            else if (key === ';') targetButton = calculatorButtons.querySelector('.btn[data-unit="in"]');
            else if (key === '\\') targetButton = calculatorButtons.querySelector('.btn[data-action="fraction"]');
            else if (key === '/') targetButton = calculatorButtons.querySelector('.btn[data-action="divide"]');
            else if (key === '+') targetButton = calculatorButtons.querySelector('.btn[data-action="add"]');
            else if (key === '-') targetButton = calculatorButtons.querySelector('.btn[data-action="subtract"]');
            else if (key === '*' || key.toLowerCase() === 'x') targetButton = calculatorButtons.querySelector('.btn[data-action="multiply"]');
            else if (key === 'Enter' || key === '=') targetButton = calculatorButtons.querySelector('.btn[data-action="calculate"]');
            else if (key === 'Backspace') targetButton = calculatorButtons.querySelector('.btn[data-action="backspace"]');
            else if (key.toLowerCase() === 'c' || key === 'Escape') targetButton = calculatorButtons.querySelector('.btn[data-action="clear"]');
            else if (key.toLowerCase() === 'v') targetButton = calculatorButtons.querySelector('.btn[data-action="convert"]'); 
            else if (key.toLowerCase() === 'm') {
                if (event.ctrlKey || event.metaKey) { 
                    targetButton = calculatorButtons.querySelector('.btn[data-action="memory-clear"]');
                } else if (event.shiftKey) { 
                    targetButton = calculatorButtons.querySelector('.btn[data-action="memory-recall"]');
                } else { 
                    targetButton = calculatorButtons.querySelector('.btn[data-action="memory-add"]');
                }
            }
            if (targetButton) {
                 event.preventDefault(); 
                 targetButton.click(); 
                 targetButton.classList.add('btn:active'); 
                 setTimeout(() => targetButton.classList.remove('btn:active'), 100);
            }
        });

        // --- Modal Event Listeners (unchanged) ---
        if (infoButton && noticeModal && modalCloseButton) {
            infoButton.addEventListener('click', () => {
                noticeModal.classList.remove('hidden');
            });
            modalCloseButton.addEventListener('click', () => {
                noticeModal.classList.add('hidden');
            });
            noticeModal.addEventListener('click', (event) => {
                if (event.target === noticeModal) { 
                    noticeModal.classList.add('hidden');
                }
            });
        } else {
            console.error("Modal elements (infoButton, noticeModal, or modalCloseButton) not found!");
        }

        // --- Initial Setup ---
        updateDisplay(); 
        updateHistoryDisplay(); 

    </script>

</body>
</html>
