<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="theme-color" content="#f97316" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#1f2937" media="(prefers-color-scheme: dark)">

    <title>ArchiCalc Beta 1.1</title>
    <link rel="icon" href=" CalcIcon.png" onerror="this.href='https://placehold.co/16x16/f97316/ffffff?text=AC'">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23f97316'%3E%3Cpath d='M12 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h8zM4 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H4z'/%3E%3Cpath d='M4 2.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-2zm0 4a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm3-6a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm3-6a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-1zm0 3a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5v-4z'/%3E%3C/svg%3E" type="image/svg+xml">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base body styles */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Ensures the app fits within the viewport without body scrollbars */
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb; /* Light mode background */
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }

        body.dark-mode {
            background-color: #111827; /* Dark mode background */
        }

        .calculator {
            width: 100%;
            max-width: 400px; /* Max width for the calculator on larger screens */
            background-color: #ffffff; /* Light mode calculator background */
            border: 2px solid #d1d5db; /* Light mode border */
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.05), 0 1px 2px -1px rgba(0, 0, 0, 0.03);
            overflow: hidden; /* Clip content within the calculator */
            display: flex;
            flex-direction: column;
            height: 100%; /* Full height on mobile */
            margin-left: auto; /* Center on desktop */
            margin-right: auto; /* Center on desktop */
            border-radius: 0.5rem; /* Square corners on mobile */
            position: relative;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .calculator.dark-mode {
            background-color: #1f2937; /* Dark mode calculator background */
            border: 2px solid #4b5563; /* Dark mode border */
        }

        /* Desktop specific styles */
        @media (min-width: 640px) {
            body {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0.25rem; /* MODIFIED: Reduced padding around calculator on desktop */
            }
            .calculator {
                height: auto; /* Allow height to be determined by content up to max-height */
                min-height: 700px; /* Minimum height on desktop */
                max-height: 90vh; /* Maximum height relative to viewport height on desktop */
                border-radius: 0.5rem; /* Rounded corners on desktop */
            }
        }

        .app-title {
            background-color: #f97316;
            color: #ffffff;
            text-align: center;
            padding: 0 1rem;
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 0.1rem;
            flex-shrink: 0; /* Prevent title from shrinking */
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 50px; /* Fixed height for the title bar */
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .calculator.dark-mode .app-title {
            background-color: #1f2937;
            color: #ffffff;
        }
        .app-title-text { flex-grow: 1; text-align: center; }
        .info-icon { cursor: pointer; padding: 0.25rem; line-height: 1; }
        .info-icon svg { transition: fill 0.3s ease; }

        /* This section contains the history tape and the main display */
        .top-section {
            display: flex;
            flex-direction: column;
            flex-grow: 1;          /* Allows this section to take up available vertical space */
            flex-shrink: 1;        /* Allows this section to shrink if needed */
            flex-basis: 0;         /* Start with no intrinsic size, grow/shrink from there */
            overflow: hidden;      /* Important for containing children properly */
            min-height: 0;         /* Crucial for flex children to shrink below content size if necessary */
        }

        .history-tape {
            background-color: #f3f4f6; /* Light mode history background */
            border-bottom: 1px solid #d1d5db; /* Light mode border */
            flex-grow: 1;          /* Allows history tape to expand and fill available space in .top-section */
            flex-shrink: 1;        /* Allows history tape to shrink */
            flex-basis: 0;         /* Start with no intrinsic size */
            overflow-y: auto;      /* Enable vertical scrolling if content overflows */
            padding: 5px 15px;
            color: #6b7280; /* Light mode history text */
            font-size: 0.85rem;
            text-align: right;
            min-height: 0;         /* Crucial for allowing shrinkage */
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            white-space: normal;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .calculator.dark-mode .history-tape {
            background-color: #374151; /* Dark mode history background */
            color: #d1d5db; /* Dark mode history text */
            border-bottom: 1px solid #4b5563; /* Dark mode border */
        }
        .history-item {
            width: 100%;
            white-space: normal;
            word-break: break-word;
            padding: 2px 0;
        }
        .calculator.dark-mode .history-item strong { color: #fde047; }

        .display-container {
            background-color: #e5e7eb; /* Light mode display background */
            border-bottom: 1px solid #d1d5db; /* Light mode border */
            height: 80px;      /* Fixed height for the display area */
            padding: 10px 15px;
            color: #1f2937; /* Light mode display text */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
            word-break: break-all;
            flex-shrink: 0; /* Prevent display container from shrinking */
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .calculator.dark-mode .display-container {
            background-color: #111827; /* Dark mode display background */
            color: #f9fafb; /* Dark mode display text */
            border-bottom: 1px solid #374151; /* Dark mode border */
        }

        .display-main {
            font-size: 2rem;
            font-weight: 600;
            overflow: hidden;
            white-space: nowrap;
            width: 100%;
            text-align: right;
            min-height: 1.2em;
            transition: color 0.3s ease;
        }
        .display-dimensional {
            font-size: 0.9rem;
            color: #4b5563; /* Light mode dimensional display text */
            height: 1.2em;
            width: 100%;
            text-align: right;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transition: color 0.3s ease;
        }
        .calculator.dark-mode .display-dimensional {
            color: #9ca3af; /* Dark mode dimensional display text */
        }

        .buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 1px;
            background-color: #d1d5db; /* Light mode button grid gap color */
            flex-shrink: 0; /* Prevent button grid from shrinking */
            height: 420px;  /* Fixed height for the button area */
            transition: background-color 0.3s ease;
        }
        .calculator.dark-mode .buttons {
            background-color: #1f2937; /* Dark mode button grid gap color */
        }

        .btn {
            background-color: #ffffff; /* Light mode default button background */
            border: none;
            text-align: center;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            color: #1f2937; /* Light mode default button text */
            width: 100%;
            height: 60px; /* Fixed height for buttons */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px;
            line-height: 1.2;
        }
        .calculator.dark-mode .btn {
            background-color: #374151; /* Dark mode default button background */
            color: #f9fafb; /* Dark mode default button text */
        }
        .calculator.dark-mode .btn:hover { background-color: #4b5563; }
        .calculator.dark-mode .btn:active { background-color: #525a66; }


        .shortcut {
            font-weight: 200;
            margin-left: 0.25rem;
            opacity: 0.8;
        }
        .calculator.dark-mode .shortcut {
            opacity: 0.7;
            color: #cbd5e1;
        }

        .btn:hover { background-color: #e5e7eb; }
        .btn:active { background-color: #d1d5db; }

        /* Button Color Styles - Light Mode */
        .btn-op { background-color: #22d3ee; color: #083344; }
        .btn-op:hover { background-color: #06b6d4; }
        .btn-unit { background-color: #e0f2fe; color: #075985; }
        .btn-unit:hover { background-color: #bae6fd; }
        .btn-conv { background-color: #bfdbfe; color: #1e40af; }
        .btn-conv:hover { background-color: #93c5fd; }
        .btn-ctrl { background-color: #d1d5db; color: #374151; }
        .btn-ctrl:hover { background-color: #9ca3af; }
        .btn-backspace-yellow { background-color: #fef9c3; color: #854d0e; }
        .btn-backspace-yellow:hover { background-color: #fde047; }
        .btn-equal { background-color: #0e7490; color: #ffffff; }
        .btn-equal:hover { background-color: #155e75; }
        .btn-mem { background-color: #eef2ff; color: #4338ca; }
        .btn-mem:hover { background-color: #c7d2fe; }
        .btn-frac { background-color: #e0f2fe; color: #075985; }
        .btn-frac:hover { background-color: #bae6fd; }

        /* Button Color Styles - Dark Mode */
        .calculator.dark-mode .btn-op { background-color: #0891b2; color: #ecfeff; }
        .calculator.dark-mode .btn-op:hover { background-color: #0e7490; }
        .calculator.dark-mode .btn-unit { background-color: #0c4a6e; color: #e0f2fe; }
        .calculator.dark-mode .btn-unit:hover { background-color: #075985; }
        .calculator.dark-mode .btn-conv { background-color: #1e40af; color: #dbeafe; }
        .calculator.dark-mode .btn-conv:hover { background-color: #1e3a8a; }
        .calculator.dark-mode .btn-ctrl { background-color: #1f2937; color: #d1d5db; }
        .calculator.dark-mode .btn-ctrl:hover { background-color: #525a66; }
        .calculator.dark-mode .btn-backspace-yellow { background-color: #713f12; color: #fefce8; }
        .calculator.dark-mode .btn-backspace-yellow:hover { background-color: #854d0e; }
        .calculator.dark-mode .btn-equal { background-color: #155e75; color: #ffffff; }
        .calculator.dark-mode .btn-equal:hover { background-color: #083344; }
        .calculator.dark-mode .btn-mem { background-color: #312e81; color: #e0e7ff; }
        .calculator.dark-mode .btn-mem:hover { background-color: #3730a3; }
        .calculator.dark-mode .btn-frac { background-color: #0c4a6e; color: #e0f2fe; }
        .calculator.dark-mode .btn-frac:hover { background-color: #075985; }

        .col-span-1 { grid-column: span 1 / span 1; }
        .col-span-2 { grid-column: span 2 / span 2; }
        .col-span-3 { grid-column: span 3 / span 3; }
        .col-span-4 { grid-column: span 4 / span 4; }
        .col-span-5 { grid-column: span 5 / span 5; }

        .flashing { animation: flash 1s infinite alternate; }
        @keyframes flash { from { opacity: 1; } to { opacity: 0.5; } }

        .modal {
            position: fixed; inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; padding: 1rem;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem; border-radius: 0.5rem;
            max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative;
            color: #374151;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .calculator.dark-mode .modal-content {
            background-color: #262f3d;
            color: #d1d5db;
        }
         .modal-content h1, .modal-content h2 {
             color: #1f2937;
             margin-top: 1rem; margin-bottom: 0.5rem; font-weight: 600;
             transition: color 0.3s ease;
         }
         .calculator.dark-mode .modal-content h1, .calculator.dark-mode .modal-content h2 {
             color: #f3f4f6;
         }
         .modal-content h1 { font-size: 1.5rem; }
         .modal-content h2 { font-size: 1.25rem; }
         .modal-content p, .modal-content li {
             margin-bottom: 0.75rem; line-height: 1.6;
         }
         .modal-content ul { list-style: disc; margin-left: 1.5rem; }
         .modal-content code {
            background-color: #e5e7eb;
            padding: 0.1rem 0.3rem; border-radius: 0.25rem; font-size: 0.85em;
            transition: background-color 0.3s ease, color 0.3s ease;
         }
         .calculator.dark-mode .modal-content code {
            background-color: #4b5563;
            color: #e0f2fe;
         }
         .modal-close-btn {
            position: absolute; top: 0.5rem; right: 0.75rem;
            background: none; border: none;
            font-size: 1.5rem; font-weight: bold;
            color: #9ca3af;
            cursor: pointer; line-height: 1;
            transition: color 0.3s ease;
         }
         .calculator.dark-mode .modal-close-btn {
             color: #6b7280;
         }
         .modal-close-btn:hover { color: #6b7280; }
         .calculator.dark-mode .modal-close-btn:hover { color: #9ca3af; }
    </style>
</head>
<body>

    <div class="calculator" id="calculator">
        <div class="app-title">
            <span class="w-8"></span> <span class="app-title-text">ArchiCalc Beta</span>
            <span id="info-button" class="info-icon" title="About ArchiCalc">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-info-circle-fill" viewBox="0 0 16 16">
                  <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm.93-9.412-1 4.705c-.07.34.029.533.304.533.194 0 .487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703 0-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381 2.29-.287zM8 5.5a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/>
                </svg>
            </span>
        </div>

        <div class="top-section"> <div id="historyTape" class="history-tape" title="Click to copy tape"></div> <div class="display-container"> <div id="displayDimensional" class="display-dimensional"></div>
                <div id="displayValue" class="display-main">0</div>
            </div>
        </div>

        <div class="buttons"> <button class="btn btn-unit" data-unit="yd" title="Convert to Yards / Square Yards / Cubic Yards">Yards</button>
            <button class="btn btn-unit" data-unit="ft" title="Convert to Feet / Square Feet / Cubic Feet">Feet<span class="shortcut">(')</span></button>
            <button class="btn btn-unit" data-unit="in" title="Convert to Inches / Square Inches / Cubic Inches">Inch<span class="shortcut">(;)</span></button>
            <button class="btn btn-frac flex flex-col items-center justify-center" data-action="fraction" title="Enter Fraction / Round Result">
                <div class="leading-tight"><sup>x</sup>&frasl;<sub>x</sub><span class="shortcut">(\)</span></div>
                <div class="text-xs font-weight-100 font-light leading-tight -mt-px">round</div>
            </button>
            <button class="btn btn-backspace-yellow" data-action="backspace">←</button>

            <button class="btn btn-unit" data-unit="cm" title="Convert to Centimeters / Square Centimeters / Cubic Centimeters">cm</button>
            <button class="btn btn-unit" data-unit="mm" title="Convert to Millimeters / Square Millimeters / Cubic Millimeters">mm</button>
            <button class="btn btn-unit" data-unit="m" title="Convert to Meters / Square Meters / Cubic Meters">m</button>
            <button class="btn btn-op" data-action="divide">÷</button>
            <button class="btn btn-conv" data-action="convert">Conv</button>

            <button class="btn" data-number="7">7</button>
            <button class="btn" data-number="8">8</button>
            <button class="btn" data-number="9">9</button>
            <button class="btn btn-op" data-action="multiply">×</button>
            <button class="btn btn-conv" data-action="sf-cu" title="Toggle Linear/Area (SQ)/Volume (CU) Mode">SQ | CU</button>

            <button class="btn" data-number="4">4</button>
            <button class="btn" data-number="5">5</button>
            <button class="btn" data-number="6">6</button>
            <button class="btn btn-op" data-action="subtract">−</button>
            <button class="btn btn-mem" data-action="memory-store" title="Store to Memory">Store</button>

            <button class="btn" data-number="1">1</button>
            <button class="btn" data-number="2">2</button>
            <button class="btn" data-number="3">3</button>
            <button class="btn btn-op" data-action="add">+</button>
            <button class="btn btn-mem" data-action="memory-recall" title="Recall from Memory">Recall</button>

            <button class="btn" data-number="0">0</button>
            <button class="btn" data-action="decimal">.</button>
            <button class="btn" data-action="sign">+/-</button>
            <button class="btn btn-equal col-span-2" data-action="calculate">=</button>

            <button class="btn btn-ctrl" data-action="clear-history">Clear Tape</button>
            <button class="btn btn-ctrl" data-action="clear">On/C</button>
            <button id="darkModeToggle" class="btn btn-ctrl" title="Toggle Dark Mode">🌙</button>
            </div>

        <img src="https://raw.githubusercontent.com/Mogrogu/ArchiCalc/main/UAI%20LOGO.png"
             alt="UAI Logo"
             id="uaiLogo"
             class="absolute bottom-2.5 right-2.5 w-[70px] rounded z-10"
             onerror="this.style.display='none'; document.getElementById('uaiLogoPlaceholder').style.display='block';"
             style="transition: filter 0.3s ease;">
        <img src="https://placehold.co/80x30/ffffff/000000?text=UAI"
             alt="UAI Logo Placeholder"
             id="uaiLogoPlaceholder"
             class="absolute bottom-2.4 right-2.5 w-[60px] rounded z-10"
             style="display:none;">
    </div>

    <div id="notice-modal" class="modal hidden">
        <div class="modal-content"> <button id="modal-close-button" class="modal-close-btn">&times;</button>
            <h1>ArchiCalc Beta</h1>
            <p>> ⚠️ <strong>Note:</strong> This is a <strong>beta release</strong> currently in the testing stage. Functionality and accuracy are still being evaluated. Feedback and bug reports are welcome.</p>
            <p><strong>ArchiCalc</strong> is a browser-based calculator designed specifically for architects, builders, and planners to perform precise dimensional calculations. It supports entry and manipulation of measurements in feet, inches, and fractions — and seamlessly converts between imperial and metric units. Perfect for planning, drafting, and on-site work where quick unit conversions and dimensional calculations are required.</p>
            <h2>Features</h2>
            <ul>
                <li><strong>Dimensional Input:</strong> Work in feet, inches, and fractional inches (e.g., <code>5 ft 6 3/8 in</code>).</li>
                <li><strong>Measurement Modes:</strong> Compute linear, area (sq. ft/in), and volume (cu. ft/in) values.</li>
                <li><strong>SQ-CU Mode:</strong> Toggle input interpretation for direct area (SQ) or volume (CU) entry with subsequent unit selection.</li>
                <li><strong>Metric Conversion:</strong> Convert between imperial and metric (meters, centimeters, millimeters).</li>
                <li><strong>Memory Functions:</strong> Store and Recall a single numerical value (overwrites previous).</li>
                <li><strong>Calculation Tape:</strong> Scrollable history tape shows recent calculations. Click tape to copy.</li>
                <li><strong>Keyboard shortcust:</strong> Keyboard shortcuts are shown next to the functions in perntacies.</li>
                <li><strong>Fraction Rounding:</strong> Round results to nearest lower architectural fraction (1/32, 1/16, 1/8, 1/4, 1/2). Press repeatedly to round further down.</li>
            </ul>
            <h2>Usage</h2>
            <ol>
                <li>Download or clone the repository or access through link.</li>
                <li>Open the <code>ArchiCalc vXX.html</code> file in your preferred modern web browser (Chrome, Firefox, Safari, Edge).</li>
                <li>Use the calculator interface directly in your browser.</li>
                <li>you can use the browser setting to install as an app on your phone or desktop</li>
                <li>No installation or backend server required.</li>
            </ol>
            <h2>Compatibility</h2>
            <ul>
                <li>Works in all modern desktop and mobile browsers.</li>
                <li>No external dependencies other than Tailwind CSS and Google Fonts (served via CDN).</li>
            </ul>
            <h2>License</h2>
            <p>Copyright © 2025 Alen Moghaddam</p>
            <p>This software is provided for personal, non-commercial use only.</p>
            <p>Permission is granted to:</p>
            <ul>
                <li>Use the calculator for private or educational architectural purposes.</li>
                <li>Modify the code for your own local use.</li>
            </ul>
            <p>You are not permitted to:</p>
            <ul>
                <li>Redistribute or sell this software or derivative works.</li>
                <li>Use it in any commercial, public-facing, or client-serving application.</li>
                <li>Host the calculator publicly without prior written permission from the author.</li>
            </ul>
            <p>This software is provided "AS IS", without warranty of any kind, express or implied. This includes but is not limited to the implied warranties of merchantability, fitness for a particular purpose, and non-infringement.</p>
            <p><strong>Disclaimer:</strong> The author shall not be held liable for any damages or consequences arising from the use or misuse of this calculator. All calculations should be independently verified before use in professional or regulatory contexts. This tool is not certified for use in code-compliant design, engineering, or life-safety-critical applications.</p>
            <h2>Contributions</h2>
            <p>This is a closed project made available for individual use. Bug reports or enhancement suggestions are welcome via GitHub issues, but this project does not currently accept public contributions or pull requests.</p>
            <h2>Author</h2>
            <p>Created by Alen Moghaddam<br>alm360@yahoo.com</p>
            <hr>
            </div>
    </div>

    <script>
        // --- DOM Elements ---
        const calculatorElement = document.getElementById('calculator');
        const historyTapeElement = document.getElementById('historyTape');
        const displayValueElement = document.getElementById('displayValue');
        const displayDimensionalElement = document.getElementById('displayDimensional');
        const calculatorButtons = document.querySelector('.buttons');
        const infoButton = document.getElementById('info-button');
        const noticeModal = document.getElementById('notice-modal');
        const modalContentElement = noticeModal.querySelector('.modal-content');
        const modalCloseButton = document.getElementById('modal-close-button');
        const darkModeToggleButton = document.getElementById('darkModeToggle');
        const uaiLogo = document.getElementById('uaiLogo');
        const uaiLogoPlaceholder = document.getElementById('uaiLogoPlaceholder');


        // --- Input State Enum ---
        const InputState = { START: 'start', ENTERING_DECIMAL: 'entering_decimal', ENTERING_FEET: 'entering_feet', ENTERING_INCHES: 'entering_inches', DIMENSIONAL_COMPLETE: 'dimensional_complete', ENTERING_NUMERATOR: 'entering_numerator', ENTERING_DENOMINATOR: 'entering_denominator', SHOWING_RESULT: 'showing_result', CONVERSION_PENDING: 'conversion_pending' };

        // --- Calculator State Variables ---
        let currentInput = '0';
        let displayShouldClear = false;
        let firstOperand = null;
        let firstOperandUnitType = 'linear';
        let firstOperandWasDimensional = false;
        let firstOperandOriginalDisplayUnit = null;
        let operator = null;
        let operatorSymbol = '';
        let memoryValue = 0;
        let history = [];
        const MAX_HISTORY_ITEMS = 30;
        let resultUnitType = 'linear';
        let inputState = InputState.START;
        let storedFeet = null;
        let storedInches = null;
        let storedNumerator = null;
        let storedDenominator = null;
        let conversionSourceInfo = { type: null, baseUnit: null, originalValueStr: null };
        let currentInputIsDimensional = false;
        let tempRoundedDisplay = null;
        let lastValueUsedForRounding = null;

        let currentDimensionMode = 'linear';
        let sqcuPressCount = 0;

        const ROUNDING_EPSILON = 0.0000001;

        // --- Conversion Factors & Units ---
        const conversionFactors = { 'in': 1, 'ft': 12, 'yd': 36, 'm': 39.3701, 'cm': 0.393701, 'mm': 0.0393701 };
        const areaConversionFactors = { 'sq in': 1, 'sq ft': 144, 'sq yd': 1296, 'sq m': 1550.0031, 'sq cm': 0.15500031, 'sq mm': 0.0015500031 };
        const volumeConversionFactors = { 'cu in': 1, 'cu ft': 1728, 'cu yd': 46656, 'cu m': 61023.744, 'cu cm': 0.061023744, 'cu mm': 0.000061023744 };
        const unitMap = { 'in': { area: 'sq in', volume: 'cu in', display: 'in' }, 'ft': { area: 'sq ft', volume: 'cu ft', display: 'ft' }, 'yd': { area: 'sq yd', volume: 'cu yd', display: 'yd' }, 'm': { area: 'sq m', volume: 'cu m', display: 'm' }, 'cm': { area: 'sq cm', volume: 'cu cm', display: 'cm' }, 'mm': { area: 'sq mm', volume: 'cu mm', display: 'mm' } };
        const displayUnits = { 'in': 'in', 'ft': 'ft', 'yd': 'yd', 'm': 'm', 'cm': 'cm', 'mm': 'mm', 'sq in': 'sq in', 'sq ft': 'sq ft', 'sq yd': 'sq yd', 'sq m': 'sq m', 'sq cm': 'sq cm', 'sq mm': 'sq mm', 'cu in': 'cu in', 'cu ft': 'cu ft', 'cu yd': 'cu yd', 'cu m': 'cu m', 'cu cm': 'cu cm', 'cu mm': 'cu mm' };
        const FRACTION_DENOMINATOR_LIMIT = 32;
        const DISPLAY_DECIMAL_PLACES = 5;

        // --- Utility Functions ---
        function gcd(a, b) { a = Math.abs(Math.round(a)); b = Math.abs(Math.round(b)); while (b) { [a, b] = [b, a % b]; } return a; }
        function resetDimensionalInput() { storedFeet = null; storedInches = null; storedNumerator = null; storedDenominator = null; currentInputIsDimensional = false; }
        function resetConversionState() { conversionSourceInfo = { type: null, baseUnit: null, originalValueStr: null }; }
        function resetSqCuMode() { currentDimensionMode = 'linear'; sqcuPressCount = 0; }
        function clearTemporaryRoundingState() { tempRoundedDisplay = null; lastValueUsedForRounding = null;}

        function resetCalculatorState(clearHistoryTape = false) {
            currentInput = '0';
            firstOperand = null;
            firstOperandWasDimensional = false;
            firstOperandUnitType = 'linear';
            firstOperandOriginalDisplayUnit = null;
            operator = null;
            operatorSymbol = '';
            displayShouldClear = false;
            resetDimensionalInput();
            resetConversionState();
            resetSqCuMode();
            inputState = InputState.START;
            displayDimensionalElement.classList.remove('flashing');
            resultUnitType = 'linear';
            clearTemporaryRoundingState();
            if (clearHistoryTape) {
                history = [];
                updateHistoryDisplay();
            }
        }

        function getDimensionalValueInches() {
            let totalInches = 0;
            if (storedFeet !== null) totalInches += storedFeet * 12;
            if (storedInches !== null) totalInches += storedInches;
            let num = storedNumerator;
            let den = storedDenominator;
            if (inputState === InputState.ENTERING_NUMERATOR && currentInput !== '0') {
                num = parseInt(currentInput);
                return (storedFeet !== null ? storedFeet * 12 : 0) + (storedInches !== null ? storedInches : 0);
            } else if (inputState === InputState.ENTERING_DENOMINATOR && currentInput !== '0') {
                den = parseInt(currentInput);
            }
            if (num !== null && den !== null && den !== 0) {
                totalInches += num / den;
            } else if (num !== null && den === 0) {
                return NaN;
            }
            return totalInches;
        }

        function formatInchesToDimensional(totalInches, forcedNumerator = null, forcedDenominator = null) {
            if (isNaN(totalInches)) return "Error";
            if (!isFinite(totalInches)) return "Infinity";

            const sign = totalInches < 0 ? "-" : "";
            const absTotalInches = Math.abs(totalInches);

            const feet = Math.floor(absTotalInches / 12);
            const remainingInchesAfterFeet = absTotalInches % 12;
            const wholeInchesPart = Math.floor(remainingInchesAfterFeet);

            let fractionStr = "";

            if (forcedNumerator !== null && forcedDenominator !== null && forcedDenominator > 0) {
                if (forcedNumerator > 0) {
                    const common = gcd(forcedNumerator, forcedDenominator);
                    fractionStr = `${forcedNumerator / common}/${forcedDenominator / common}`;
                }
            } else {
                const fractionalPartOfInches = remainingInchesAfterFeet - wholeInchesPart;
                if (fractionalPartOfInches > ROUNDING_EPSILON) {
                    let bestNum = Math.round(fractionalPartOfInches * FRACTION_DENOMINATOR_LIMIT);
                    let bestDen = FRACTION_DENOMINATOR_LIMIT;
                    if (bestNum > 0) {
                        const commonDivisor = gcd(bestNum, bestDen);
                        bestNum /= commonDivisor;
                        bestDen /= commonDivisor;
                        if (bestDen > 0 && bestNum < bestDen) {
                            fractionStr = `${bestNum}/${bestDen}`;
                        }
                    }
                }
            }

            let parts = [];
            if (feet > 0) parts.push(`${feet} ft`);

            let inchesDisplayString = '';
            if (wholeInchesPart > 0) {
                inchesDisplayString = `${wholeInchesPart}`;
            }

            if (fractionStr) {
                if (inchesDisplayString) {
                    inchesDisplayString += ` ${fractionStr}`;
                } else {
                    inchesDisplayString = fractionStr;
                }
            }

            if (inchesDisplayString) {
                parts.push(inchesDisplayString);
                if (!parts.some(p => p.includes("in")) && (wholeInchesPart > 0 || fractionStr || (feet === 0 && totalInches !==0))) {
                     parts.push('in');
                } else if (feet > 0 && (wholeInchesPart > 0 || fractionStr) && !parts[parts.length-1].endsWith("in")) {
                     parts.push('in');
                }
            } else if (feet === 0 && Math.abs(absTotalInches) < ROUNDING_EPSILON) {
                return "0 in";
            } else if (feet > 0 && wholeInchesPart === 0 && !fractionStr) {
            } else if (feet === 0 && wholeInchesPart === 0 && !fractionStr && totalInches !== 0) {
                if (Math.abs(totalInches) > ROUNDING_EPSILON) {
                    return `${sign}${totalInches.toFixed(3)} in`;
                }
            }


            const formattedString = sign + parts.join(' ').trim();
            return formattedString === "" || formattedString === "-" ? (totalInches === 0 ? "0 in" : sign + "0 in") : formattedString;
        }
        function formatAreaDisplay(totalSqInches, unit = 'sq ft') {
            if (isNaN(totalSqInches)) return "Error";
            if (!isFinite(totalSqInches)) return "Infinity";
            const sign = totalSqInches < 0 ? "-" : "";
            totalSqInches = Math.abs(totalSqInches);

            let mainDisplayValue, dimensionalDisplayValue;
            if (unit === 'sq ft') {
                const sqFeetValue = totalSqInches / areaConversionFactors['sq ft'];
                mainDisplayValue = `${sign}${formatDisplayNumber(String(sqFeetValue))} sq ft`;
                dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(totalSqInches))} sq in`;
            } else if (unit === 'sq in') {
                mainDisplayValue = `${sign}${formatDisplayNumber(String(totalSqInches))} sq in`;
                const sqFeetValue = totalSqInches / areaConversionFactors['sq ft'];
                dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(sqFeetValue))} sq ft`;
            } else if (areaConversionFactors[unit]) {
                 const valueInTargetUnit = totalSqInches / areaConversionFactors[unit];
                 mainDisplayValue = `${sign}${formatDisplayNumber(String(valueInTargetUnit))} ${displayUnits[unit]}`;
                 dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(totalSqInches))} sq in`;
            } else {
                const sqFeetValue = totalSqInches / areaConversionFactors['sq ft'];
                mainDisplayValue = `${sign}${formatDisplayNumber(String(sqFeetValue))} sq ft`;
                dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(totalSqInches))} sq in`;
            }
            return { main: mainDisplayValue, dimensional: dimensionalDisplayValue };
        }
        function formatVolumeDisplay(totalCuInches, unit = 'cu ft') {
            if (isNaN(totalCuInches)) return "Error";
            if (!isFinite(totalCuInches)) return "Infinity";
            const sign = totalCuInches < 0 ? "-" : "";
            totalCuInches = Math.abs(totalCuInches);

            let mainDisplayValue, dimensionalDisplayValue;
            if (unit === 'cu ft') {
                const cuFeetValue = totalCuInches / volumeConversionFactors['cu ft'];
                mainDisplayValue = `${sign}${formatDisplayNumber(String(cuFeetValue))} cu ft`;
                dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(totalCuInches))} cu in`;
            } else if (unit === 'cu in') {
                 mainDisplayValue = `${sign}${formatDisplayNumber(String(totalCuInches))} cu in`;
                 const cuFeetValue = totalCuInches / volumeConversionFactors['cu ft'];
                 dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(cuFeetValue))} cu ft`;
            } else if (volumeConversionFactors[unit]) {
                const valueInTargetUnit = totalCuInches / volumeConversionFactors[unit];
                mainDisplayValue = `${sign}${formatDisplayNumber(String(valueInTargetUnit))} ${displayUnits[unit]}`;
                dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(totalCuInches))} cu in`;
            } else {
                const cuFeetValue = totalCuInches / volumeConversionFactors['cu ft'];
                mainDisplayValue = `${sign}${formatDisplayNumber(String(cuFeetValue))} cu ft`;
                dimensionalDisplayValue = `${sign}${formatDisplayNumber(String(totalCuInches))} cu in`;
            }
            return { main: mainDisplayValue, dimensional: dimensionalDisplayValue };
        }
        function formatCurrentDimensionalInput() {
            let parts = [];
            if (storedFeet !== null) parts.push(`${storedFeet} ft`);

            let inchesPart = '';
            if (storedInches !== null) inchesPart = `${storedInches}`;

            if (inputState === InputState.ENTERING_NUMERATOR) {
                let fractionPreview = currentInput === '0' ? '' : currentInput;
                if (fractionPreview) displayDimensionalElement.classList.add('flashing'); else displayDimensionalElement.classList.remove('flashing');
                if(inchesPart) inchesPart += ` ${fractionPreview}`; else inchesPart = fractionPreview;
            } else if (inputState === InputState.ENTERING_DENOMINATOR) {
                let fractionPreview = `${storedNumerator}/${currentInput === '0' ? '' : currentInput}`;
                if (currentInput !== '0') displayDimensionalElement.classList.add('flashing'); else displayDimensionalElement.classList.remove('flashing');
                if(inchesPart) inchesPart += ` ${fractionPreview}`; else inchesPart = fractionPreview;
            } else if (storedNumerator !== null && storedDenominator !== null) {
                const commonDivisor = gcd(storedNumerator, storedDenominator);
                let fractionPreview = `${storedNumerator / commonDivisor}/${storedDenominator / commonDivisor}`;
                if(inchesPart) inchesPart += ` ${fractionPreview}`; else inchesPart = fractionPreview;
            }

            if (inchesPart) parts.push(inchesPart);

            if (inchesPart || (storedFeet === null && (inputState === InputState.ENTERING_INCHES || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR))) {
                if (!parts.some(p => p.includes("in")) && (inchesPart.trim() !== '' || (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR))) {
                    const lastPart = parts[parts.length -1];
                    if (!(lastPart && lastPart.includes('/') && storedDenominator === null && inputState !== InputState.ENTERING_DENOMINATOR)) {
                        parts.push('in');
                    }
                }
            }

            if (inputState !== InputState.ENTERING_NUMERATOR && inputState !== InputState.ENTERING_DENOMINATOR) {
                displayDimensionalElement.classList.remove('flashing');
            }
            return parts.join(' ').trim();
        }
        function finalizeDimensionalInput() {
            let totalInches = NaN;
            if (currentInputIsDimensional) {
                totalInches = getDimensionalValueInches();
            }
            return totalInches;
        }
        function updateDisplay() {
            if (tempRoundedDisplay) {
                displayValueElement.textContent = tempRoundedDisplay.main;
                displayDimensionalElement.textContent = tempRoundedDisplay.dimensional;
                return;
            }

            let mainDisplayValue;
            let dimensionalDisplayValue = '';
            displayDimensionalElement.classList.remove('flashing');

            if (inputState === InputState.SHOWING_RESULT) {
                const resultValue = parseFloat(currentInput); // currentInput is now always the base unit value for results

                if (resultUnitType === 'volume') {
                    // resultValue is total cubic inches
                    const volDisplay = formatVolumeDisplay(resultValue, 'cu ft'); // Default to cu ft display
                    mainDisplayValue = volDisplay.main;
                    dimensionalDisplayValue = volDisplay.dimensional;
                } else if (resultUnitType === 'area') {
                    // resultValue is total square inches
                    const areaDisplay = formatAreaDisplay(resultValue, 'sq ft'); // Default to sq ft display
                    mainDisplayValue = areaDisplay.main;
                    dimensionalDisplayValue = areaDisplay.dimensional;
                } else if (resultUnitType === 'linear' && firstOperandWasDimensional) {
                    // resultValue is total inches
                    mainDisplayValue = formatInchesToDimensional(resultValue);
                    dimensionalDisplayValue = formatDisplayNumber(String(resultValue)) + " in";
                } else {
                    // Plain number result (scalar, or direct unit input that's linear)
                    mainDisplayValue = formatDisplayNumber(String(resultValue));
                    dimensionalDisplayValue = firstOperandWasDimensional ? (formatDisplayNumber(String(resultValue)) + ' (scalar)') : '';
                    if (conversionSourceInfo.type && displayUnits[conversionSourceInfo.type] && currentInput !== '0') {
                        dimensionalDisplayValue = `${mainDisplayValue} ${displayUnits[conversionSourceInfo.type]}`;
                    } else if (conversionSourceInfo.originalValueStr) {
                         dimensionalDisplayValue = conversionSourceInfo.originalValueStr;
                    }
                }
            } else if (inputState === InputState.CONVERSION_PENDING) {
                let valueToConvertFormatted = formatDisplayNumber(String(firstOperand));
                if (conversionSourceInfo.type === 'area') {
                    valueToConvertFormatted = formatAreaDisplay(firstOperand, conversionSourceInfo.baseUnit || 'sq in').main;
                } else if (conversionSourceInfo.type === 'volume') {
                    valueToConvertFormatted = formatVolumeDisplay(firstOperand, conversionSourceInfo.baseUnit || 'cu in').main;
                } else if (conversionSourceInfo.type === 'linear' && (conversionSourceInfo.baseUnit === 'in' || conversionSourceInfo.baseUnit )) {
                    valueToConvertFormatted = formatInchesToDimensional(firstOperand);
                } else if (conversionSourceInfo.originalValueStr) {
                    valueToConvertFormatted = conversionSourceInfo.originalValueStr;
                }
                dimensionalDisplayValue = `Conv ${valueToConvertFormatted} → ?`;
                mainDisplayValue = formatDisplayNumber(String(firstOperand));
            } else if (currentInputIsDimensional || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) {
                dimensionalDisplayValue = formatCurrentDimensionalInput();
                mainDisplayValue = (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) ? currentInput : formatDisplayNumber(currentInput);
            } else if (conversionSourceInfo.type && displayUnits[conversionSourceInfo.type] && currentInput !== '0') {
                mainDisplayValue = formatDisplayNumber(currentInput);
                dimensionalDisplayValue = `${mainDisplayValue} ${displayUnits[conversionSourceInfo.type]}`;
            } else { // Default display for plain numbers
                mainDisplayValue = formatDisplayNumber(currentInput);
                dimensionalDisplayValue = '';
            }


            if (currentDimensionMode === 'area' && sqcuPressCount === 1 && inputState !== InputState.SHOWING_RESULT && inputState !== InputState.CONVERSION_PENDING) {
                dimensionalDisplayValue = "SQ Mode (Area)";
            } else if (currentDimensionMode === 'volume' && sqcuPressCount === 2 && inputState !== InputState.SHOWING_RESULT && inputState !== InputState.CONVERSION_PENDING) {
                 dimensionalDisplayValue = "CU Mode (Volume)";
            }


            displayValueElement.textContent = mainDisplayValue;
            displayDimensionalElement.textContent = dimensionalDisplayValue;
        }
        function updateHistoryDisplay() {
            historyTapeElement.innerHTML = '';
            for (let i = 0; i < history.length; i++) {
                const historyItemDiv = document.createElement('div');
                historyItemDiv.classList.add('history-item');
                historyItemDiv.innerHTML = history[i];
                historyTapeElement.appendChild(historyItemDiv);
            }
            historyTapeElement.scrollTop = historyTapeElement.scrollHeight;
        }
        function addHistoryEntry(entry) { console.log("addHistoryEntry:", entry); history.push(entry); if (history.length > MAX_HISTORY_ITEMS) { history.shift(); } updateHistoryDisplay(); }
        function clearHistory() { console.log("clearHistory: Clear Tape pressed"); history = []; updateHistoryDisplay(); addHistoryEntry("Tape Cleared"); }
        function formatDisplayNumber(valueStr) { const errorMessages = ['Error', 'Set Unit', 'Cannot Add/Sub Area', 'Cannot Add/Sub L & A', 'Cannot Conv Area', 'Cannot Conv Volume', 'Cannot Add/Sub Volume', 'Cannot Add/Sub A & V', 'Cannot Add/Sub L & V', 'Cannot Mult V & L', 'Cannot Div by Zero']; if (errorMessages.includes(valueStr)) { return valueStr; } const maxLength = 12; let hasTrailingDecimal = valueStr.endsWith('.'); let displayStr = valueStr; if (hasTrailingDecimal) { displayStr = valueStr.slice(0, -1); } const numericValue = parseFloat(displayStr); if (isNaN(numericValue)) { return (displayStr === '0' || displayStr === '') ? '0' : 'Error'; } let formattedNumber; if (Math.abs(numericValue) > 1e12 || (Math.abs(numericValue) < 1e-6 && numericValue !== 0)) { formattedNumber = numericValue.toExponential(maxLength - 6); } else { let roundedValueStr; if (displayStr.includes('.')) { roundedValueStr = numericValue.toFixed(DISPLAY_DECIMAL_PLACES); roundedValueStr = roundedValueStr.replace(/0+$/, '').replace(/\.$/, ''); } else { roundedValueStr = displayStr; } const parts = roundedValueStr.split('.'); parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","); formattedNumber = parts.join('.'); } if (hasTrailingDecimal && !formattedNumber.includes('.') && !formattedNumber.toLowerCase().includes('e')) { formattedNumber += '.'; } return formattedNumber.slice(0, maxLength); }

        // --- Input Handling Functions ---
        function restorePreciseValueAndClearRounding() {
            if (tempRoundedDisplay) {
                currentInput = tempRoundedDisplay.preciseValue;
                clearTemporaryRoundingState();
            }
        }
        function inputDigit(digit) {
            restorePreciseValueAndClearRounding();
            resetSqCuMode();

            if (inputState === InputState.SHOWING_RESULT) {
                resetCalculatorState();
                currentInput = digit;
                inputState = InputState.START;
            } else if (inputState === InputState.DIMENSIONAL_COMPLETE) {
                if (storedInches !== null || storedFeet !== null) {
                    inputState = InputState.ENTERING_NUMERATOR;
                    currentInput = digit;
                    displayShouldClear = false;
                    currentInputIsDimensional = true;
                } else {
                    resetCalculatorState();
                    currentInput = digit;
                    inputState = InputState.START;
                }
            } else if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) {
                if (currentInput === '0' && digit === '0') { /* allow leading zero if that's all */ }
                else if (currentInput.length < 4) {
                     currentInput = currentInput === '0' ? digit : currentInput + digit;
                }
            } else {
                if (displayShouldClear) {
                    currentInput = '0';
                    displayShouldClear = false;
                    if (inputState !== InputState.ENTERING_INCHES && inputState !== InputState.ENTERING_NUMERATOR && inputState !== InputState.ENTERING_DENOMINATOR && inputState !== InputState.DIMENSIONAL_COMPLETE) {
                        resetDimensionalInput();
                        resetConversionState();
                        inputState = InputState.START;
                    }
                }
                if (currentInput === '0' && digit === '0') { /* allow leading zero if that's all */ }
                else if (currentInput.length < 10) {
                    currentInput = currentInput === '0' ? digit : currentInput + digit;
                }
                if (inputState === InputState.START && !currentInputIsDimensional) {
                     inputState = InputState.ENTERING_FEET;
                }
            }
            updateDisplay();
        }
        function inputDecimal() {
            restorePreciseValueAndClearRounding();
            resetSqCuMode();

            if (inputState === InputState.SHOWING_RESULT) {
                resetCalculatorState();
                currentInput = '0.';
                inputState = InputState.ENTERING_DECIMAL;
            } else if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) {
                updateDisplay(); return;
            } else if (displayShouldClear) {
                currentInput = '0.';
                displayShouldClear = false;
                resetDimensionalInput();
                resetConversionState();
                inputState = InputState.ENTERING_DECIMAL;
            } else if (!currentInput.includes('.')) {
                if (inputState === InputState.DIMENSIONAL_COMPLETE) {
                    resetDimensionalInput();
                    resetConversionState();
                    currentInput = '0.';
                    inputState = InputState.ENTERING_DECIMAL;
                } else {
                    currentInput += '.';
                    if (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_INCHES) {
                        inputState = InputState.ENTERING_DECIMAL;
                    }
                }
            }
            updateDisplay();
        }

        function performCalculation(op1, op1Type, op1IsDim, op2, op2Type, op2IsDim, operation) {
            console.log(`performCalculation: op1=${op1} (${op1Type}, dim:${op1IsDim}), op2=${op2} (${op2Type}, dim:${op2IsDim}), operation=${operation}`);
            if (op1 === null || isNaN(op1) || isNaN(op2)) {
                return { value: NaN, unitType: 'linear', isDimensional: false, error: 'Invalid Operand' };
            }

            let resultValue = 0;
            let resultUnitTypeCalc = 'linear';
            let resultIsDimensionalCalc = false;

            if (operation === 'add' || operation === 'subtract') {
                if (op1Type !== op2Type) {
                    return { value: NaN, unitType: 'linear', isDimensional: false, error: `Cannot Add/Sub ${op1Type} & ${op2Type}` };
                }
                resultUnitTypeCalc = op1Type;
                resultIsDimensionalCalc = op1IsDim || op2IsDim;
            } else if (operation === 'multiply') {
                if (op1Type === 'linear' && op2Type === 'linear') {
                    if (op1IsDim && op2IsDim) {
                        resultUnitTypeCalc = 'area';
                        resultIsDimensionalCalc = true;
                    } else if (op1IsDim || op2IsDim) {
                        resultUnitTypeCalc = 'linear';
                        resultIsDimensionalCalc = true;
                    } else {
                        resultUnitTypeCalc = 'linear';
                        resultIsDimensionalCalc = false;
                    }
                } else if ((op1Type === 'area' && op2Type === 'linear') || (op1Type === 'linear' && op2Type === 'area')) {
                    const linearOpIsDim = (op1Type === 'linear' ? op1IsDim : op2IsDim);
                    if (linearOpIsDim) {
                        resultUnitTypeCalc = 'volume';
                    } else {
                        resultUnitTypeCalc = 'area';
                    }
                    resultIsDimensionalCalc = true;
                } else if ((op1Type === 'volume' && op2Type === 'linear') || (op1Type === 'linear' && op2Type === 'volume')) {
                    const linearOpIsDim = (op1Type === 'linear' ? op1IsDim : op2IsDim);
                    if (linearOpIsDim) {
                        return { value: NaN, unitType: 'linear', isDimensional: false, error: "Cannot Mult V & L(dim)" };
                    } else {
                        resultUnitTypeCalc = 'volume';
                    }
                    resultIsDimensionalCalc = true;
                } else {
                    return { value: NaN, unitType: 'linear', isDimensional: false, error: `Cannot Mult ${op1Type} & ${op2Type}` };
                }
            } else if (operation === 'divide') {
                if (op2 === 0) {
                    return { value: NaN, unitType: 'linear', isDimensional: false, error: "Cannot Div by Zero" };
                }
                if (op1Type === 'linear' && op2Type === 'linear') {
                    resultUnitTypeCalc = 'linear';
                    if (op1IsDim && op2IsDim) {
                        resultIsDimensionalCalc = false;
                    } else if (op1IsDim && !op2IsDim) {
                        resultIsDimensionalCalc = true;
                    } else {
                        resultIsDimensionalCalc = !op1IsDim && !op2IsDim ? false : true;
                         if (!op1IsDim && op2IsDim) {
                             resultIsDimensionalCalc = false;
                         }
                    }
                } else if (op1Type === 'area' && op2Type === 'linear') {
                    resultUnitTypeCalc = op2IsDim ? 'linear' : 'area';
                    resultIsDimensionalCalc = true;
                } else if (op1Type === 'volume' && op2Type === 'linear') {
                    resultUnitTypeCalc = op2IsDim ? 'area' : 'volume';
                    resultIsDimensionalCalc = true;
                } else if (op1Type === 'volume' && op2Type === 'area') {
                    resultUnitTypeCalc = 'linear';
                    resultIsDimensionalCalc = true;
                } else if (op1Type === 'area' && op2Type === 'area') {
                    resultUnitTypeCalc = 'linear';
                    resultIsDimensionalCalc = false;
                } else if (op1Type === 'volume' && op2Type === 'volume') {
                    resultUnitTypeCalc = 'linear';
                    resultIsDimensionalCalc = false;
                } else {
                    return { value: NaN, unitType: 'linear', isDimensional: false, error: `Cannot Div ${op1Type} by ${op2Type}` };
                }
            }

            switch (operation) {
                case 'add': resultValue = op1 + op2; break;
                case 'subtract': resultValue = op1 - op2; break;
                case 'multiply': resultValue = op1 * op2; break;
                case 'divide': resultValue = op1 / op2; break;
                default:
                    console.warn("Unknown operation:", operation);
                    return { value: op2, unitType: op2Type, isDimensional: op2IsDim };
            }
            console.log(`performCalculation: Result = ${resultValue} (${resultUnitTypeCalc}, dim:${resultIsDimensionalCalc})`);
            return { value: resultValue, unitType: resultUnitTypeCalc, isDimensional: resultIsDimensionalCalc };
        }

        function handleOperator(newOperator) {
            restorePreciseValueAndClearRounding();
            resetSqCuMode();

            const operatorSymbols = { 'add': '+', 'subtract': '−', 'multiply': '×', 'divide': '÷' };
            const newOperatorSymbol = operatorSymbols[newOperator] || '';

            if (storedFeet !== null && inputState === InputState.ENTERING_INCHES && currentInput !== '0' && !isNaN(parseFloat(currentInput))) {
                const inchesVal = parseFloat(currentInput);
                if (!isNaN(inchesVal)) {
                    storedInches = inchesVal;
                    currentInput = String(getDimensionalValueInches());
                    inputState = InputState.DIMENSIONAL_COMPLETE;
                    currentInputIsDimensional = true;
                }
            }


            if (inputState === InputState.SHOWING_RESULT) {
                let rawValueFromDisplay = parseFloat(currentInput); // currentInput is base value for SHOWING_RESULT
                let baseUnitValue = rawValueFromDisplay; // Already in base units

                // Determined unit type and dimensional status from previous result state
                let determinedUnitType = resultUnitType;
                let determinedWasDimensional = firstOperandWasDimensional;

                // If the previous result was a specific unit input (e.g. "5m"), that info is in conversionSourceInfo.
                // We keep the currentInput as the base unit value.
                // The historyOperandDisplay needs to reflect the original displayed unit.
                let historyOperandDisplay = conversionSourceInfo.originalValueStr || '';

                if (determinedUnitType === 'area') {
                    historyOperandDisplay = formatAreaDisplay(baseUnitValue, conversionSourceInfo.type || 'sq ft').main; // Use conversionSourceInfo.type as preferred
                } else if (determinedUnitType === 'volume') {
                    historyOperandDisplay = formatVolumeDisplay(baseUnitValue, conversionSourceInfo.type || 'cu ft').main; // Use conversionSourceInfo.type as preferred
                } else if (determinedUnitType === 'linear' && determinedWasDimensional) {
                    historyOperandDisplay = formatInchesToDimensional(baseUnitValue); // Base value is inches
                } else {
                    historyOperandDisplay = formatDisplayNumber(String(baseUnitValue)); // Plain number
                }

                firstOperand = baseUnitValue;
                firstOperandUnitType = determinedUnitType;
                firstOperandWasDimensional = determinedWasDimensional;
                firstOperandOriginalDisplayUnit = historyOperandDisplay; // Store the formatted string for history

                operator = newOperator;
                operatorSymbol = newOperatorSymbol;

                addHistoryEntry(`${historyOperandDisplay} ${operatorSymbol}`);

                displayShouldClear = true;
                inputState = InputState.START;
                resetConversionState();
                resetDimensionalInput();
                updateDisplay();
                return;
            }

            let inputValue;
            let inputUnitType = 'linear';
            let inputWasDimensional = false;
            let inputOriginalDisplayString = formatDisplayNumber(currentInput);

            if (inputState === InputState.ENTERING_INCHES || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE) {
                inputValue = finalizeDimensionalInput();
                inputUnitType = 'linear';
                inputWasDimensional = true;
                inputOriginalDisplayString = formatInchesToDimensional(inputValue);
                resetDimensionalInput();
            } else if (conversionSourceInfo.type && conversionSourceInfo.baseUnit && conversionFactors[conversionSourceInfo.type]) {
                inputValue = parseFloat(currentInput) * conversionFactors[conversionSourceInfo.type];
                inputUnitType = 'linear';
                inputWasDimensional = true;
                inputOriginalDisplayString = conversionSourceInfo.originalValueStr || `${formatDisplayNumber(currentInput)} ${displayUnits[conversionSourceInfo.type]}`;
            } else {
                inputValue = parseFloat(currentInput);
                inputUnitType = 'linear';
                inputWasDimensional = false;
            }

            if (isNaN(inputValue)) {
                currentInput = 'Error';
                resetCalculatorState();
                inputState = InputState.SHOWING_RESULT;
                resultUnitType = 'linear';
                updateDisplay();
                return;
            }

            if (operator && firstOperand !== null) {
                const calcResult = performCalculation(firstOperand, firstOperandUnitType, firstOperandWasDimensional, inputValue, inputUnitType, inputWasDimensional, operator);

                if (calcResult.error) { currentInput = calcResult.error; resetCalculatorState(); inputState = InputState.SHOWING_RESULT; updateDisplay(); return; }
                if (isNaN(calcResult.value)) { currentInput = 'Error'; resetCalculatorState(); inputState = InputState.SHOWING_RESULT; updateDisplay(); return; }

                if (history.length > 0) {
                    let lastEntryIndex = history.length - 1;
                    if (history[lastEntryIndex] && history[lastEntryIndex].trim().endsWith(operatorSymbol)) {
                         history[lastEntryIndex] = `${history[lastEntryIndex]} ${inputOriginalDisplayString}`;
                         updateHistoryDisplay();
                    }
                }

                firstOperand = calcResult.value;
                firstOperandUnitType = calcResult.unitType;
                firstOperandWasDimensional = calcResult.isDimensional;
                firstOperandOriginalDisplayUnit = null;

                currentInput = String(firstOperand); // CurrentInput is now the base unit value for this new result
                resultUnitType = firstOperandUnitType;

                let resultForHistoryDisplay;
                if (firstOperandUnitType === 'area') resultForHistoryDisplay = formatAreaDisplay(firstOperand, 'sq ft').main;
                else if (firstOperandUnitType === 'volume') resultForHistoryDisplay = formatVolumeDisplay(firstOperand, 'cu ft').main;
                else if (firstOperandWasDimensional) resultForHistoryDisplay = formatInchesToDimensional(firstOperand);
                else resultForHistoryDisplay = formatDisplayNumber(String(firstOperand));

                addHistoryEntry(`${resultForHistoryDisplay} ${newOperatorSymbol}`);

            } else {
                firstOperand = inputValue;
                firstOperandUnitType = inputUnitType;
                firstOperandWasDimensional = inputWasDimensional;
                firstOperandOriginalDisplayUnit = inputOriginalDisplayString;

                addHistoryEntry(`${inputOriginalDisplayString} ${newOperatorSymbol}`);
            }

            operator = newOperator;
            operatorSymbol = newOperatorSymbol;
            displayShouldClear = true;
            inputState = InputState.START;
            resetDimensionalInput();
            resetConversionState();
            updateDisplay();
        }

        function handleEquals() {
            restorePreciseValueAndClearRounding();

            if (!operator || firstOperand === null) {
                if (inputState === InputState.ENTERING_INCHES || inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR) {
                    const finalVal = finalizeDimensionalInput();
                    if (!isNaN(finalVal)) {
                        currentInput = String(finalVal);
                        firstOperandWasDimensional = true;
                        resultUnitType = 'linear';
                        conversionSourceInfo = { type: 'in', baseUnit: 'in', originalValueStr: formatInchesToDimensional(finalVal) };
                        inputState = InputState.SHOWING_RESULT;
                        addHistoryEntry(`${formatInchesToDimensional(finalVal)} = <strong>${formatInchesToDimensional(finalVal)}</strong>`);
                        resetDimensionalInput();
                        updateDisplay();
                        return;
                    }
                } else if (inputState === InputState.SHOWING_RESULT) { updateDisplay(); return; }
                else if (!isNaN(parseFloat(currentInput)) && (inputState === InputState.START || inputState === InputState.ENTERING_DECIMAL || inputState === InputState.ENTERING_FEET)) {
                    inputState = InputState.SHOWING_RESULT;
                    resultUnitType = 'linear';
                    firstOperandWasDimensional = false;
                    conversionSourceInfo = { type: null, baseUnit: null, originalValueStr: formatDisplayNumber(currentInput) };
                    addHistoryEntry(`${formatDisplayNumber(currentInput)} = <strong>${formatDisplayNumber(currentInput)}</strong>`);
                    updateDisplay();
                    return;
                } else { updateDisplay(); return; }
            }

            let secondOperandValue;
            let secondOperandUnitType = 'linear';
            let secondOperandWasDimensional = false;
            let secondOperandOriginalDisplayString = formatDisplayNumber(currentInput);

            if (inputState === InputState.ENTERING_INCHES || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE) {
                secondOperandValue = finalizeDimensionalInput();
                secondOperandUnitType = 'linear';
                secondOperandWasDimensional = true;
                secondOperandOriginalDisplayString = formatInchesToDimensional(secondOperandValue);
                resetDimensionalInput();
            } else if (inputState === InputState.SHOWING_RESULT) {
                // When equals is pressed and the second operand is already a displayed result
                let rawValue = parseFloat(currentInput); // currentInput is a base value here
                secondOperandValue = rawValue;
                secondOperandUnitType = resultUnitType;
                secondOperandWasDimensional = firstOperandWasDimensional;

                // Use original string from conversionSourceInfo, or format based on current base value
                if (conversionSourceInfo.originalValueStr) {
                    secondOperandOriginalDisplayString = conversionSourceInfo.originalValueStr;
                } else if (secondOperandUnitType === 'area') {
                    secondOperandOriginalDisplayString = formatAreaDisplay(secondOperandValue, 'sq ft').main;
                } else if (secondOperandUnitType === 'volume') {
                    secondOperandOriginalDisplayString = formatVolumeDisplay(secondOperandValue, 'cu ft').main;
                } else if (secondOperandUnitType === 'linear' && secondOperandWasDimensional) {
                    secondOperandOriginalDisplayString = formatInchesToDimensional(secondOperandValue);
                } else {
                    secondOperandOriginalDisplayString = formatDisplayNumber(String(secondOperandValue));
                }

            } else {
                secondOperandValue = parseFloat(currentInput);
                secondOperandOriginalDisplayString = formatDisplayNumber(currentInput);
            }

            if (isNaN(secondOperandValue)) { currentInput = 'Error'; resetCalculatorState(); inputState = InputState.SHOWING_RESULT; updateDisplay(); return; }

            const calcResult = performCalculation(firstOperand, firstOperandUnitType, firstOperandWasDimensional, secondOperandValue, secondOperandUnitType, secondOperandWasDimensional, operator);

            if (calcResult.error) { currentInput = calcResult.error; resetCalculatorState(); inputState = InputState.SHOWING_RESULT; updateDisplay(); return; }
            if (isNaN(calcResult.value)) { currentInput = 'Error'; resetCalculatorState(); inputState = InputState.SHOWING_RESULT; updateDisplay(); return; }

            currentInput = String(calcResult.value); // currentInput always stores the BASE unit value for results
            resultUnitType = calcResult.unitType;
            firstOperandWasDimensional = calcResult.isDimensional;

            // conversionSourceInfo for results will now explicitly store BASE unit type if dimensional
            if (resultUnitType === 'linear') {
                conversionSourceInfo = {
                    type: firstOperandWasDimensional ? 'in' : null,
                    baseUnit: firstOperandWasDimensional ? 'in' : null,
                    originalValueStr: firstOperandWasDimensional ? formatInchesToDimensional(calcResult.value) : formatDisplayNumber(String(calcResult.value))
                };
            } else if (resultUnitType === 'area') {
                conversionSourceInfo = { type: 'sq in', baseUnit: 'sq in', originalValueStr: formatAreaDisplay(calcResult.value, 'sq ft').main };
            } else if (resultUnitType === 'volume') {
                conversionSourceInfo = { type: 'cu in', baseUnit: 'cu in', originalValueStr: formatVolumeDisplay(calcResult.value, 'cu ft').main };
            } else {
                 resetConversionState();
            }

            inputState = InputState.SHOWING_RESULT;

            if (history.length > 0) {
                let lastEntryIndex = history.length - 1;
                let resultDisplayString;
                if (resultUnitType === 'volume') resultDisplayString = formatVolumeDisplay(calcResult.value, firstOperandOriginalDisplayUnit && firstOperandOriginalDisplayUnit.includes('cu') ? firstOperandOriginalDisplayUnit : 'cu ft').main;
                else if (resultUnitType === 'area') resultDisplayString = formatAreaDisplay(calcResult.value, firstOperandOriginalDisplayUnit && firstOperandOriginalDisplayUnit.includes('sq') ? firstOperandOriginalDisplayUnit : 'sq ft').main;
                else if (firstOperandWasDimensional) resultDisplayString = formatInchesToDimensional(calcResult.value);
                else resultDisplayString = formatDisplayNumber(String(calcResult.value));

                if (history[lastEntryIndex] && history[lastEntryIndex].trim().endsWith(operatorSymbol)) {
                    history[lastEntryIndex] = `${history[lastEntryIndex]} ${secondOperandOriginalDisplayString} = <strong>${resultDisplayString}</strong>`;
                } else {
                    let firstOpDisplay = firstOperandOriginalDisplayUnit ||
                                         (firstOperandUnitType === 'area' ? formatAreaDisplay(firstOperand, 'sq ft').main :
                                          firstOperandUnitType === 'volume' ? formatVolumeDisplay(firstOperand, 'cu ft').main :
                                          (firstOperandWasDimensional && firstOperandUnitType === 'linear') ? formatInchesToDimensional(firstOperand) :
                                          formatDisplayNumber(String(firstOperand)));
                    addHistoryEntry(`${firstOpDisplay} ${operatorSymbol} ${secondOperandOriginalDisplayString} = <strong>${resultDisplayString}</strong>`);
                }
                updateHistoryDisplay();
            }

            operator = null;
            operatorSymbol = '';
            displayShouldClear = true;
            resetDimensionalInput();
            resetSqCuMode();
            updateDisplay();
        }

        function clearCalculator() {
            console.log("clearCalculator: On/C pressed");
            restorePreciseValueAndClearRounding();
            resetCalculatorState();
            addHistoryEntry('------');
            updateDisplay();
        }

        function handleUnit(unitKey) {
            restorePreciseValueAndClearRounding();
            console.log(`handleUnit: ${unitKey}, State: ${inputState}, currentInput: ${currentInput}, currentDimensionMode: ${currentDimensionMode}`);

            const rawNumericValue = parseFloat(currentInput);

            if (currentDimensionMode !== 'linear') {
                if (isNaN(rawNumericValue)) { currentInput = 'Error'; updateDisplay(); return; }

                let targetUnitName = '';
                let historyDisplayString = `${formatDisplayNumber(String(rawNumericValue))}`;

                if (currentDimensionMode === 'area') {
                    targetUnitName = unitMap[unitKey]?.area;
                    if (!targetUnitName || !areaConversionFactors[targetUnitName]) { currentInput = 'Set Unit'; updateDisplay(); return; }
                    historyDisplayString += ` ${displayUnits[targetUnitName]}`;

                    // currentInput is the magnitude in targetUnitName (e.g. "5" for 5 sq ft)
                    // Store the base unit value in currentInput for internal consistency
                    currentInput = String(rawNumericValue * areaConversionFactors[targetUnitName]);
                    resultUnitType = 'area';
                    conversionSourceInfo = { type: 'sq in', baseUnit: 'sq in', originalValueStr: historyDisplayString }; // Base unit type
                } else if (currentDimensionMode === 'volume') {
                    targetUnitName = unitMap[unitKey]?.volume;
                    if (!targetUnitName || !volumeConversionFactors[targetUnitName]) { currentInput = 'Set Unit'; updateDisplay(); return; }
                    historyDisplayString += ` ${displayUnits[targetUnitName]}`;

                    // Store the base unit value in currentInput
                    currentInput = String(rawNumericValue * volumeConversionFactors[targetUnitName]);
                    resultUnitType = 'volume';
                    conversionSourceInfo = { type: 'cu in', baseUnit: 'cu in', originalValueStr: historyDisplayString }; // Base unit type
                }

                firstOperandWasDimensional = true;
                addHistoryEntry(historyDisplayString);
                inputState = InputState.SHOWING_RESULT;
                displayShouldClear = true;
                resetDimensionalInput();
                resetSqCuMode();
                updateDisplay();
                return;
            }

            if (inputState === InputState.CONVERSION_PENDING && conversionSourceInfo.type) {
                let valueInBaseUnits = firstOperand; // This is already in base units
                let targetUnitFullName = null;
                let conversionFactorsTable = null;
                let newResultUnitType = conversionSourceInfo.type.startsWith('sq') ? 'area' : conversionSourceInfo.type.startsWith('cu') ? 'volume' : 'linear';
                let convertedResult;
                let originalUnitForHistory = conversionSourceInfo.baseUnit || (conversionSourceInfo.type === 'linear' ? 'in' : conversionSourceInfo.type === 'area' ? 'sq in' : 'cu in');

                if (newResultUnitType === 'area') {
                    targetUnitFullName = unitMap[unitKey]?.area;
                    conversionFactorsTable = areaConversionFactors;
                    if (!targetUnitFullName || !conversionFactorsTable[targetUnitFullName]) { currentInput = 'Cannot Conv Area'; updateDisplay(); return; }
                    convertedResult = valueInBaseUnits / conversionFactorsTable[targetUnitFullName];
                } else if (newResultUnitType === 'volume') {
                    targetUnitFullName = unitMap[unitKey]?.volume;
                    conversionFactorsTable = volumeConversionFactors;
                    if (!targetUnitFullName || !conversionFactorsTable[targetUnitFullName]) { currentInput = 'Cannot Conv Volume'; updateDisplay(); return; }
                    convertedResult = valueInBaseUnits / conversionFactorsTable[targetUnitFullName];
                } else { // Linear conversion
                    targetUnitFullName = unitKey;
                    conversionFactorsTable = conversionFactors;
                    if (!conversionFactorsTable[targetUnitFullName]) { currentInput = 'Set Unit'; updateDisplay(); return; }
                    convertedResult = valueInBaseUnits / conversionFactorsTable[targetUnitFullName];
                }

                let fromFormattedString = conversionSourceInfo.originalValueStr ||
                                        (newResultUnitType === 'area' ? formatAreaDisplay(valueInBaseUnits, originalUnitForHistory).main :
                                         newResultUnitType === 'volume' ? formatVolumeDisplay(valueInBaseUnits, originalUnitForHistory).main :
                                         formatInchesToDimensional(valueInBaseUnits));

                const toFormattedString = `${formatDisplayNumber(String(convertedResult))} ${displayUnits[targetUnitFullName]}`;
                addHistoryEntry(`Conv ${fromFormattedString} → <strong>${toFormattedString}</strong>`);

                currentInput = String(valueInBaseUnits); // Current input is base unit value
                resultUnitType = newResultUnitType;
                firstOperandWasDimensional = true;
                conversionSourceInfo = { type: targetUnitFullName, baseUnit: targetUnitFullName, originalValueStr: toFormattedString };

                inputState = InputState.SHOWING_RESULT;
                firstOperand = null;
                displayShouldClear = true;
                resetDimensionalInput();
                updateDisplay();
                return;
            }

            if (inputState === InputState.SHOWING_RESULT) {
                // If a unit is pressed on a result, it triggers a conversion.
                let valueToConvertInBase = parseFloat(currentInput); // currentInput is base unit value
                let sourceTypeOfValueToConvert = resultUnitType;
                let sourceOriginalDisplay = conversionSourceInfo.originalValueStr || displayValueElement.textContent;


                if (sourceTypeOfValueToConvert !== 'linear' || !conversionFactors[unitKey]) {
                    // Cannot convert area/volume result by just pressing a linear unit key.
                    // Or trying to convert linear result to non-linear unit by this method.
                    currentInput = 'Set Unit'; updateDisplay(); return;
                }

                // If conversion is valid (linear to linear)
                const targetUnitFactor = conversionFactors[unitKey];
                const convertedVal = valueToConvertInBase / targetUnitFactor;
                const fromFormatted = sourceOriginalDisplay; // Use original display string for "from"
                const toFormatted = `${formatDisplayNumber(String(convertedVal))} ${displayUnits[unitKey]}`;
                addHistoryEntry(`Conv ${fromFormatted} → <strong>${toFormatted}</strong>`);

                currentInput = String(valueToConvertInBase); // CurrentInput remains base value
                resultUnitType = 'linear';
                firstOperandWasDimensional = true;
                conversionSourceInfo = { type: unitKey, baseUnit: 'in', originalValueStr: toFormatted };
                inputState = InputState.SHOWING_RESULT;
                resetDimensionalInput();
                updateDisplay();
                return;
            }

            const valueFromDisplay = parseFloat(currentInput);
            const hasValue = !isNaN(valueFromDisplay) && (currentInput !== '0' || (currentInput === '0' && (inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_INCHES)));


            if (unitKey === 'ft') {
                 if (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) {
                    storedFeet = hasValue ? valueFromDisplay : (storedFeet === null ? 0 : storedFeet);
                    inputState = InputState.ENTERING_INCHES;
                    currentInput = '0';
                    displayShouldClear = true;
                    currentInputIsDimensional = true;
                    resetConversionState();
                } else if (inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.ENTERING_INCHES) {
                    const prevFinalized = finalizeDimensionalInput();
                    if (!isNaN(prevFinalized) && operator === null) firstOperand = prevFinalized;

                    resetDimensionalInput();
                    storedFeet = hasValue ? valueFromDisplay : 0;
                    inputState = InputState.ENTERING_INCHES;
                    currentInput = '0';
                    currentInputIsDimensional = true;
                    displayShouldClear = true;
                    resetConversionState();
                }
            } else if (unitKey === 'in') {
                if (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) {
                    storedFeet = storedFeet !== null ? storedFeet : 0;
                    storedInches = hasValue ? valueFromDisplay : 0;
                    inputState = InputState.DIMENSIONAL_COMPLETE;
                    currentInput = '0';
                    displayShouldClear = true;
                    currentInputIsDimensional = true;
                    resetConversionState();
                } else if (inputState === InputState.ENTERING_INCHES) {
                    storedInches = hasValue ? valueFromDisplay : (storedInches === null ? 0 : storedInches);
                    inputState = InputState.DIMENSIONAL_COMPLETE;
                    currentInput = '0';
                    displayShouldClear = true;
                    currentInputIsDimensional = true;
                    resetConversionState();
                } else if (inputState === InputState.ENTERING_DENOMINATOR) {
                    const denominatorValue = parseInt(currentInput);
                    if (!isNaN(denominatorValue) && denominatorValue !== 0 && storedNumerator !== null) {
                        storedDenominator = denominatorValue;
                        const finalDimensionalValue = finalizeDimensionalInput();
                        if (!isNaN(finalDimensionalValue)) {
                            currentInput = String(finalDimensionalValue); // This is in inches
                            firstOperandWasDimensional = true;
                            resultUnitType = 'linear';
                            conversionSourceInfo = { type: 'in', baseUnit: 'in', originalValueStr: formatInchesToDimensional(finalDimensionalValue) };
                            inputState = InputState.SHOWING_RESULT;
                            addHistoryEntry(conversionSourceInfo.originalValueStr);
                            displayShouldClear = true;
                        } else { currentInput = 'Error'; updateDisplay(); return; }
                    } else { updateDisplay(); return; }
                } else if (inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_NUMERATOR) {
                    const finalVal = finalizeDimensionalInput();
                    if (!isNaN(finalVal)) {
                        currentInput = String(finalVal); // This is in inches
                        firstOperandWasDimensional = true;
                        resultUnitType = 'linear';
                        conversionSourceInfo = { type: 'in', baseUnit: 'in', originalValueStr: formatInchesToDimensional(finalVal) };
                        inputState = InputState.SHOWING_RESULT;
                        addHistoryEntry(conversionSourceInfo.originalValueStr);
                        displayShouldClear = true;
                    }
                }
            } else if (conversionFactors[unitKey]) {
                if (inputState === InputState.START || inputState === InputState.ENTERING_DECIMAL || inputState === InputState.ENTERING_FEET) {
                    if (!isNaN(valueFromDisplay)) {
                        currentInput = String(valueFromDisplay * conversionFactors[unitKey]); // Store as base inches
                        resultUnitType = 'linear';
                        firstOperandWasDimensional = true;
                        let originalDisplay = `${formatDisplayNumber(String(valueFromDisplay))} ${displayUnits[unitKey]}`;
                        conversionSourceInfo = { type: unitKey, baseUnit: unitKey, originalValueStr: originalDisplay };
                        inputState = InputState.SHOWING_RESULT;
                        addHistoryEntry(originalDisplay);
                        displayShouldClear = true;
                        resetDimensionalInput();
                    } else { currentInput = 'Error'; updateDisplay(); }
                }
            }
            updateDisplay();
        }

        function handleConvert() {
            restorePreciseValueAndClearRounding();
            resetSqCuMode();

            let valueToConvertInBaseUnits;
            let sourceInfoForPendingConv = { type: null, baseUnit: null, originalValueStr: null };

            if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_INCHES) {
                valueToConvertInBaseUnits = finalizeDimensionalInput();
                sourceInfoForPendingConv = { type: 'in', baseUnit: 'in', originalValueStr: formatInchesToDimensional(valueToConvertInBaseUnits) }; // Base unit type
                resetDimensionalInput();
            } else if (inputState === InputState.SHOWING_RESULT) {
                // currentInput is already the base unit value for SHOWING_RESULT state
                valueToConvertInBaseUnits = parseFloat(currentInput);

                // Determine the base unit type based on resultUnitType
                let baseUnitTypeForConversion = resultUnitType;
                if (resultUnitType === 'area') baseUnitTypeForConversion = 'sq in';
                else if (resultUnitType === 'volume') baseUnitTypeForConversion = 'cu in';
                else baseUnitTypeForConversion = 'in'; // For linear, base is inches

                sourceInfoForPendingConv = {
                    type: baseUnitTypeForConversion, // Current base unit type
                    baseUnit: baseUnitTypeForConversion,
                    originalValueStr: conversionSourceInfo.originalValueStr || displayValueElement.textContent // Preserve original display string
                };
            } else if (conversionSourceInfo.type && conversionSourceInfo.baseUnit) {
                // For direct unit input (e.g. "5 m") that's not yet a result, currentInput is the value in that unit
                valueToConvertInBaseUnits = parseFloat(currentInput) * conversionFactors[conversionSourceInfo.type]; // Convert to inches
                sourceInfoForPendingConv = { type: 'in', baseUnit: 'in', originalValueStr: conversionSourceInfo.originalValueStr };
            } else if (!isNaN(parseFloat(currentInput))) {
                valueToConvertInBaseUnits = parseFloat(currentInput);
                sourceInfoForPendingConv = { type: 'in', baseUnit: 'in', originalValueStr: formatDisplayNumber(currentInput) };
            } else { currentInput = 'Error'; updateDisplay(); return; }

            if (isNaN(valueToConvertInBaseUnits)) { currentInput = 'Error'; updateDisplay(); return; }

            inputState = InputState.CONVERSION_PENDING;
            firstOperand = valueToConvertInBaseUnits; // Store the base unit value for conversion
            conversionSourceInfo = sourceInfoForPendingConv; // Store info about the source for the Conv display
            displayShouldClear = true;
            resetDimensionalInput();
            updateDisplay();
        }

        function roundToNearestLowerArchitectural(totalInches, strictlyLower = false) {
            if (isNaN(totalInches) || !isFinite(totalInches)) {
                return { roundedValueInches: totalInches, bestNumerator: null, bestDenominator: null, roundingOccurred: false };
            }

            const sign = totalInches < 0 ? -1 : 1;
            const absTotalInches = Math.abs(totalInches);
            const wholeInches = Math.floor(absTotalInches);
            let originalFractionalPartOfInches = absTotalInches - wholeInches;

            if (strictlyLower && originalFractionalPartOfInches < ROUNDING_EPSILON) {
                if (absTotalInches < ROUNDING_EPSILON) {
                     return { roundedValueInches: 0, bestNumerator: 0, bestDenominator: 1, roundingOccurred: false };
                }
                if (wholeInches > 0) {
                    return {
                        roundedValueInches: sign * (wholeInches - 1 + (FRACTION_DENOMINATOR_LIMIT -1) / FRACTION_DENOMINATOR_LIMIT),
                        bestNumerator: FRACTION_DENOMINATOR_LIMIT -1,
                        bestDenominator: FRACTION_DENOMINATOR_LIMIT,
                        roundingOccurred: true
                    };
                } else {
                     originalFractionalPartOfInches = 1.0 - ROUNDING_EPSILON;
                }
            } else if (strictlyLower) {
                 originalFractionalPartOfInches -= ROUNDING_EPSILON;
                 if (originalFractionalPartOfInches < 0) originalFractionalPartOfInches = 0;
            }


            if (originalFractionalPartOfInches < ROUNDING_EPSILON && !strictlyLower) {
                return { roundedValueInches: totalInches, bestNumerator: 0, bestDenominator: 1, roundingOccurred: false };
            }


            const architecturalDenominators = [32, 16, 8, 4, 2];
            let bestLowerFractionValue = -1;
            let finalNumerator = 0;
            let finalDenominator = 1;
            let foundRoundingCandidate = false;

            for (const archDen of architecturalDenominators) {
                let potentialNumerator = Math.floor(originalFractionalPartOfInches * archDen + ROUNDING_EPSILON);

                if (potentialNumerator >= archDen) potentialNumerator = archDen -1;
                if (potentialNumerator < 0) potentialNumerator = 0;

                const currentLowerFractionVal = potentialNumerator / archDen;

                if (currentLowerFractionVal <= originalFractionalPartOfInches + ROUNDING_EPSILON) {
                    if (currentLowerFractionVal > bestLowerFractionValue - ROUNDING_EPSILON) {
                        bestLowerFractionValue = currentLowerFractionVal;
                        finalNumerator = potentialNumerator;
                        finalDenominator = archDen;
                        foundRoundingCandidate = true;
                    }
                }
            }

            if (!foundRoundingCandidate || finalNumerator === 0 && bestLowerFractionValue < ROUNDING_EPSILON) {
                finalNumerator = 0;
                finalDenominator = 1;
                bestLowerFractionValue = 0;
            } else {
                 const common = gcd(finalNumerator, finalDenominator);
                 finalNumerator /= common;
                 finalDenominator /= common;
            }

            const finalRoundedInches = sign * (wholeInches + bestLowerFractionValue);
            const roundingOccurred = Math.abs(finalRoundedInches - totalInches) > ROUNDING_EPSILON || (strictlyLower && totalInches > finalRoundedInches + ROUNDING_EPSILON );

            return {
                roundedValueInches: finalRoundedInches,
                bestNumerator: finalNumerator,
                bestDenominator: finalDenominator,
                roundingOccurred: roundingOccurred
            };
        }
        function handleFraction() {
            console.log(`handleFraction: State: ${inputState}, currentInput: ${currentInput}, lastValueUsedForRounding: ${lastValueUsedForRounding}`);
            resetSqCuMode();

            if (inputState === InputState.SHOWING_RESULT) {
                let valueToProcessForRounding;
                let originalCalcResultStringForPreciseValue = currentInput;
                let isSubsequentRounding = tempRoundedDisplay && lastValueUsedForRounding !== null;

                if (isSubsequentRounding) {
                    valueToProcessForRounding = lastValueUsedForRounding;
                    originalCalcResultStringForPreciseValue = tempRoundedDisplay.preciseValue;
                } else {
                    const preciseResultNumeric = parseFloat(currentInput);
                    if (isNaN(preciseResultNumeric)) { currentInput = 'Error'; updateDisplay(); return; }

                    let valueInInchesForRounding;
                    if (resultUnitType === 'linear') {
                        // For a linear result, currentInput is already in inches (base unit)
                        valueInInchesForRounding = preciseResultNumeric;
                    } else { currentInput = 'Not Linear'; updateDisplay(); return; }
                    valueToProcessForRounding = valueInInchesForRounding;
                }

                const { roundedValueInches, bestNumerator, bestDenominator, roundingOccurred } = roundToNearestLowerArchitectural(valueToProcessForRounding, isSubsequentRounding);

                if (roundingOccurred || !isSubsequentRounding) {
                    if (isSubsequentRounding && Math.abs(roundedValueInches - lastValueUsedForRounding) < ROUNDING_EPSILON && bestNumerator === 0 && roundedValueInches < ROUNDING_EPSILON) {
                        if (tempRoundedDisplay && tempRoundedDisplay.preciseValue !== undefined) {
                             currentInput = tempRoundedDisplay.preciseValue;
                             clearTemporaryRoundingState();
                             addHistoryEntry("Rounding limit reached, restored original.");
                             updateDisplay();
                             return;
                        }
                    }

                    const roundedDisplayString = formatInchesToDimensional(roundedValueInches, bestNumerator, bestDenominator);
                    addHistoryEntry(`rounded --> <strong>${roundedDisplayString}</strong>`);

                    tempRoundedDisplay = {
                        main: roundedDisplayString,
                        dimensional: formatDisplayNumber(String(roundedValueInches)) + " in (rounded)",
                        preciseValue: originalCalcResultStringForPreciseValue
                    };
                    lastValueUsedForRounding = roundedValueInches;
                    updateDisplay();
                } else {
                    addHistoryEntry("No further rounding possible.");
                }
                return;
            }

            clearTemporaryRoundingState();
            if (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) {
                const numValue = parseInt(currentInput);
                if (!isNaN(numValue) && currentInput.indexOf('.') === -1) {
                    storedFeet = storedFeet !== null ? storedFeet : null;
                    storedInches = storedInches !== null ? storedInches : (storedFeet !== null ? 0 : null);

                    storedNumerator = numValue;
                    inputState = InputState.ENTERING_DENOMINATOR;
                    currentInput = '0';
                    displayShouldClear = true;
                    currentInputIsDimensional = true;
                } else if (currentInput === '0' && (inputState === InputState.START || inputState === InputState.ENTERING_FEET)) {
                    storedFeet = storedFeet !== null ? storedFeet : null;
                    storedInches = storedInches !== null ? storedInches : (storedFeet !== null ? 0 : null);
                    inputState = InputState.ENTERING_NUMERATOR;
                    currentInput = '0';
                    displayShouldClear = true;
                    currentInputIsDimensional = true;
                } else { console.warn("handleFraction: Invalid value or state for starting fraction directly."); }
            } else if (inputState === InputState.ENTERING_INCHES || inputState === InputState.DIMENSIONAL_COMPLETE) {
                const inchesValue = parseFloat(currentInput);
                if (inputState === InputState.ENTERING_INCHES && !isNaN(inchesValue)) {
                    storedInches = inchesValue;
                } else if (storedInches === null && storedFeet !== null) {
                    storedInches = 0;
                }

                inputState = InputState.ENTERING_NUMERATOR;
                currentInput = '0';
                displayShouldClear = true;
                currentInputIsDimensional = true;
            } else if (inputState === InputState.ENTERING_NUMERATOR) {
                const numeratorValue = parseInt(currentInput);
                if (!isNaN(numeratorValue)) {
                    storedNumerator = numeratorValue;
                    inputState = InputState.ENTERING_DENOMINATOR;
                    currentInput = '0';
                    displayShouldClear = true;
                } else { console.warn("handleFraction: Invalid numerator value."); }
            } else { console.log("handleFraction: Ignoring fraction button in current state:", inputState); }
            updateDisplay();
        }
        function memoryStore() {
            restorePreciseValueAndClearRounding();
            resetSqCuMode();
            let valueToStoreInBaseUnits;
            let typeOfValue = 'linear';

            if (inputState === InputState.ENTERING_NUMERATOR || inputState === InputState.ENTERING_DENOMINATOR || inputState === InputState.DIMENSIONAL_COMPLETE || inputState === InputState.ENTERING_INCHES) {
                valueToStoreInBaseUnits = finalizeDimensionalInput();
                typeOfValue = 'linear';
                resetDimensionalInput();
            } else if (inputState === InputState.SHOWING_RESULT) {
                // currentInput is already the base value here
                valueToStoreInBaseUnits = parseFloat(currentInput);
                typeOfValue = resultUnitType;
            } else if (conversionSourceInfo.type && conversionSourceInfo.baseUnit) {
                valueToStoreInBaseUnits = parseFloat(currentInput) * conversionFactors[conversionSourceInfo.type];
                typeOfValue = 'linear';
            } else {
                valueToStoreInBaseUnits = parseFloat(currentInput);
                typeOfValue = 'linear';
            }

            if (!isNaN(valueToStoreInBaseUnits)) {
                // Store base value, its type, and a formatted display string for recall history
                memoryValue = {
                    value: valueToStoreInBaseUnits,
                    type: typeOfValue,
                    originalDisplay: updateDisplayAndGetFormattedValue(valueToStoreInBaseUnits, typeOfValue) // Get formatted string
                };
                displayDimensionalElement.textContent = "Stored";
                addHistoryEntry(`Stored: ${memoryValue.originalDisplay}`);
                setTimeout(() => { updateDisplay(); }, 500);
                displayShouldClear = true;
            } else { currentInput = 'Error Store'; updateDisplay(); }
        }

        function updateDisplayAndGetFormattedValue(value, type) {
            if (type === 'area') return formatAreaDisplay(value, 'sq ft').main;
            if (type === 'volume') return formatVolumeDisplay(value, 'cu ft').main;
            if (type === 'linear') return formatInchesToDimensional(value);
            return formatDisplayNumber(String(value));
        }

        function memoryRecall() {
            restorePreciseValueAndClearRounding();
            if (memoryValue && typeof memoryValue === 'object' && memoryValue.value !== undefined) {
                resetCalculatorState();
                currentInput = String(memoryValue.value); // currentInput becomes the base value from memory
                resultUnitType = memoryValue.type;
                firstOperandWasDimensional = true; // Recalled value is considered dimensional

                // Set conversionSourceInfo to reflect the base unit type of the recalled value
                if (memoryValue.type === 'linear') {
                    conversionSourceInfo = { type: 'in', baseUnit: 'in', originalValueStr: memoryValue.originalDisplay };
                } else if (memoryValue.type === 'area') {
                    conversionSourceInfo = { type: 'sq in', baseUnit: 'sq in', originalValueStr: memoryValue.originalDisplay };
                } else if (memoryValue.type === 'volume') {
                    conversionSourceInfo = { type: 'cu in', baseUnit: 'cu in', originalValueStr: memoryValue.originalDisplay };
                }

                inputState = InputState.SHOWING_RESULT;
                addHistoryEntry(`Recalled: ${memoryValue.originalDisplay}`);
            } else {
                resetCalculatorState();
                currentInput = String(memoryValue);
                inputState = InputState.SHOWING_RESULT;
                firstOperandWasDimensional = true;
                resultUnitType = 'linear';
                conversionSourceInfo = { type: 'in', baseUnit: 'in', originalValueStr: formatInchesToDimensional(parseFloat(currentInput)) };
                addHistoryEntry(`Recalled: ${formatInchesToDimensional(parseFloat(currentInput))}`);
            }
            updateDisplay();
        }
        function toggleSign() {
            restorePreciseValueAndClearRounding();
            resetSqCuMode();
            if ( (inputState === InputState.START || inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) ||
                 (inputState === InputState.SHOWING_RESULT && resultUnitType === 'linear' && !firstOperandWasDimensional && !conversionSourceInfo.type) ) {
                const numericValue = parseFloat(currentInput);
                if (!isNaN(numericValue) && numericValue !== 0) {
                    currentInput = String(numericValue * -1);
                }
            }
            updateDisplay();
        }
        function handleBackspace() {
            if (tempRoundedDisplay) {
                currentInput = tempRoundedDisplay.preciseValue;
                clearTemporaryRoundingState();
                updateDisplay();
                return;
            }

            if (inputState === InputState.SHOWING_RESULT || inputState === InputState.CONVERSION_PENDING) {
                return;
            }
            if (currentInput === '0' || currentInput === '') {
                if (inputState === InputState.ENTERING_DENOMINATOR) {
                    currentInput = String(storedNumerator !== null ? storedNumerator : '0');
                    storedNumerator = null;
                    inputState = InputState.ENTERING_NUMERATOR;
                    displayShouldClear = false;
                } else if (inputState === InputState.ENTERING_NUMERATOR) {
                    currentInput = String(storedInches !== null ? storedInches : '0');
                    storedNumerator = null;
                    inputState = storedInches !== null ? InputState.DIMENSIONAL_COMPLETE : (storedFeet !== null ? InputState.ENTERING_INCHES : InputState.ENTERING_FEET);
                    displayShouldClear = false;
                } else if (inputState === InputState.DIMENSIONAL_COMPLETE) {
                    if (storedInches !== null) {
                        currentInput = String(storedInches);
                        storedInches = null;
                        inputState = InputState.ENTERING_INCHES;
                    } else if (storedFeet !== null) {
                        currentInput = String(storedFeet);
                        storedFeet = null;
                        inputState = InputState.ENTERING_FEET;
                        currentInputIsDimensional = false;
                    }
                    displayShouldClear = false;
                } else if (inputState === InputState.ENTERING_INCHES) {
                    currentInput = String(storedFeet !== null ? storedFeet : '0');
                    storedFeet = null;
                    inputState = InputState.ENTERING_FEET;
                    currentInputIsDimensional = false;
                    displayShouldClear = false;
                } else if (inputState === InputState.ENTERING_FEET || inputState === InputState.ENTERING_DECIMAL) {
                    currentInputIsDimensional = false;
                }
            } else {
                 if (currentInput.length > 1) {
                    currentInput = currentInput.slice(0, -1);
                    if (!currentInput.includes('.') && inputState === InputState.ENTERING_DECIMAL) {
                         if (/^\d+$/.test(currentInput)) inputState = InputState.ENTERING_FEET;
                         else if (currentInput === '0') inputState = InputState.START;
                    }
                } else {
                    currentInput = '0';
                    if (inputState === InputState.ENTERING_DECIMAL && !currentInput.includes('.')) inputState = InputState.ENTERING_FEET;
                }
            }
            updateDisplay();
        }
        function handleSqCu() {
            restorePreciseValueAndClearRounding();
            sqcuPressCount++;

            if (sqcuPressCount === 1) {
                currentDimensionMode = 'area';
            } else if (sqcuPressCount === 2) {
                currentDimensionMode = 'volume';
            } else {
                sqcuPressCount = 0;
                currentDimensionMode = 'linear';
            }

            updateDisplay();

            setTimeout(() => {
                if (sqcuPressCount > 0 && (currentDimensionMode === 'area' || currentDimensionMode === 'volume')) {
                     if (displayDimensionalElement.textContent === "SQ Mode (Area)" ||
                         displayDimensionalElement.textContent === "CU Mode (Volume)") {
                         if (currentInput === '0' && inputState !== InputState.SHOWING_RESULT) {
                            displayDimensionalElement.textContent = "";
                         } else {
                            updateDisplay();
                         }
                     }
                } else if (sqcuPressCount === 0 && displayDimensionalElement.textContent === "Linear Mode") {
                    if (currentInput === '0' && inputState !== InputState.SHOWING_RESULT) {
                        displayDimensionalElement.textContent = "";
                    } else {
                        updateDisplay();
                    }
                }
            }, 1500);
        }

        function setDarkMode(isDark) {
            if (isDark) {
                document.body.classList.add('dark-mode');
                calculatorElement.classList.add('dark-mode');
                darkModeToggleButton.textContent = '☼';
                darkModeToggleButton.title = "Toggle Light Mode";
                if (uaiLogo) uaiLogo.style.filter = 'brightness(0) invert(1)';

            } else {
                document.body.classList.remove('dark-mode');
                calculatorElement.classList.remove('dark-mode');
                darkModeToggleButton.textContent = '🌙';
                darkModeToggleButton.title = "Toggle Dark Mode";
                if (uaiLogo) uaiLogo.style.filter = 'none';
            }
        }

        darkModeToggleButton.addEventListener('click', () => {
            const isDarkMode = document.body.classList.contains('dark-mode');
            setDarkMode(!isDarkMode);
            try { localStorage.setItem('darkMode', !isDarkMode); } catch (e) { console.warn("LocalStorage not available for dark mode preference."); }
        });

        let prefersDarkInit = false;
        try { prefersDarkInit = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch (e) { /*ignore*/ }

        let savedDarkModeInit = null;
        try { savedDarkModeInit = localStorage.getItem('darkMode'); } catch (e) { /*ignore*/ }


        if (savedDarkModeInit === 'true') setDarkMode(true);
        else if (savedDarkModeInit === 'false') setDarkMode(false);
        else setDarkMode(prefersDarkInit);


        calculatorButtons.addEventListener('click', (event) => {
            const target = event.target.closest('button');
            if (!target) return;
            const action = target.dataset.action;
            const number = target.dataset.number;
            const unit = target.dataset.unit;

            if (action !== 'fraction' && action !== 'sf-cu' && tempRoundedDisplay) {
                restorePreciseValueAndClearRounding();
            }

            if (number !== undefined) inputDigit(number);
            else if (unit !== undefined) handleUnit(unit);
            else if (action !== undefined) {
                switch (action) {
                    case 'add': case 'subtract': case 'multiply': case 'divide': handleOperator(action); break;
                    case 'decimal': inputDecimal(); break;
                    case 'calculate': handleEquals(); break;
                    case 'clear': clearCalculator(); break;
                    case 'backspace': handleBackspace(); break;
                    case 'convert': handleConvert(); break;
                    case 'fraction': handleFraction(); break;
                    case 'memory-store': memoryStore(); break;
                    case 'memory-recall': memoryRecall(); break;
                    case 'sf-cu': handleSqCu(); break;
                    case 'sign': toggleSign(); break;
                    case 'clear-history': clearHistory(); break;
                    default: console.warn("Unknown action:", action);
                }
            }
        });

        window.addEventListener('keydown', (event) => {
            const key = event.key;
            let targetButton = null;

            if ((event.ctrlKey || event.metaKey) && key.toLowerCase() === 'c') {
                event.preventDefault();
                const textToCopy = displayValueElement.textContent;
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = textToCopy;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                    displayDimensionalElement.textContent = "Copied Display!";
                    setTimeout(() => {
                        if (displayDimensionalElement.textContent === "Copied Display!") updateDisplay();
                    }, 1000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    displayDimensionalElement.textContent = "Copy Failed";
                     setTimeout(() => {
                        if (displayDimensionalElement.textContent === "Copy Failed") updateDisplay();
                    }, 1000);
                }
                document.body.removeChild(tempTextArea);
                return;
            }


            if (/[0-9]/.test(key)) targetButton = calculatorButtons.querySelector(`.btn[data-number="${key}"]`);
            else if (key === '.') targetButton = calculatorButtons.querySelector('.btn[data-action="decimal"]');
            else if (key === "'") targetButton = calculatorButtons.querySelector('.btn[data-unit="ft"]');
            else if (key === ';') targetButton = calculatorButtons.querySelector('.btn[data-unit="in"]');
            else if (key === '\\') targetButton = calculatorButtons.querySelector('.btn[data-action="fraction"]');
            else if (key === '/') targetButton = calculatorButtons.querySelector('.btn[data-action="divide"]');
            else if (key === '+') targetButton = calculatorButtons.querySelector('.btn[data-action="add"]');
            else if (key === '-') targetButton = calculatorButtons.querySelector('.btn[data-action="subtract"]');
            else if (key === '*' || key.toLowerCase() === 'x') targetButton = calculatorButtons.querySelector('.btn[data-action="multiply"]');
            else if (key === 'Enter' || key === '=') targetButton = calculatorButtons.querySelector('.btn[data-action="calculate"]');
            else if (key === 'Backspace') targetButton = calculatorButtons.querySelector('.btn[data-action="backspace"]');
            else if (key.toLowerCase() === 'c' && !(event.ctrlKey || event.metaKey)) targetButton = calculatorButtons.querySelector('.btn[data-action="clear"]');
            else if (key === 'Escape') targetButton = calculatorButtons.querySelector('.btn[data-action="clear"]');
            else if (key.toLowerCase() === 'v') targetButton = calculatorButtons.querySelector('.btn[data-action="convert"]');
            else if (key.toLowerCase() === 's' && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                targetButton = calculatorButtons.querySelector('.btn[data-action="memory-store"]');
            } else if (key.toLowerCase() === 'r' && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                targetButton = calculatorButtons.querySelector('.btn[data-action="memory-recall"]');
            } else if (key.toLowerCase() === 'u') {
                 targetButton = calculatorButtons.querySelector('.btn[data-action="sf-cu"]');
            }

            if (targetButton) {
                 event.preventDefault();
                 targetButton.click();
                 targetButton.classList.add('btn:active');
                 setTimeout(() => targetButton.classList.remove('btn:active'), 100);
            }
        });

        if (infoButton && noticeModal && modalCloseButton) {
            infoButton.addEventListener('click', () => {
                noticeModal.classList.remove('hidden');
            });
            modalCloseButton.addEventListener('click', () => {
                noticeModal.classList.add('hidden');
            });
            noticeModal.addEventListener('click', (event) => {
                if (event.target === noticeModal) {
                    noticeModal.classList.add('hidden');
                }
            });
        } else {
            console.error("Modal elements (infoButton, noticeModal, or modalCloseButton) not found!");
        }

        // Event listener for copying history tape
        historyTapeElement.addEventListener('click', () => {
            const tapeContent = history.map(entry => {
                // Strip HTML tags for plain text copy
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = entry;
                return tempDiv.textContent || tempDiv.innerText || "";
            }).join('\n');

            if (!tapeContent) {
                displayDimensionalElement.textContent = "Tape Empty";
                setTimeout(() => { if (displayDimensionalElement.textContent === "Tape Empty") updateDisplay(); }, 1000);
                return;
            }

            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = tapeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            try {
                document.execCommand('copy');
                displayDimensionalElement.textContent = "Tape Copied!";
                setTimeout(() => { if (displayDimensionalElement.textContent === "Tape Copied!") updateDisplay(); }, 1000);
            } catch (err) {
                console.error('Failed to copy tape: ', err);
                displayDimensionalElement.textContent = "Copy Failed";
                setTimeout(() => { if (displayDimensionalElement.textContent === "Copy Failed") updateDisplay(); }, 1000);
            }
            document.body.removeChild(tempTextArea);
        });


        updateDisplay();
        updateHistoryDisplay();
    </script>

</body>
</html>
